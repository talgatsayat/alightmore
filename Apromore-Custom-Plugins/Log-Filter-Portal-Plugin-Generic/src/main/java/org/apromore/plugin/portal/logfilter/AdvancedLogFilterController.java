/*-
 * #%L
 * This file is part of "Apromore Core".
 * %%
 * Copyright (C) 2018 - 2022 Apromore Pty Ltd.
 * %%
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Lesser Public License for more details.
 *
 * You should have received a copy of the GNU General Lesser Public
 * License along with this program.  If not, see
 * <http://www.gnu.org/licenses/lgpl-3.0.html>.
 * #L%
 */

package org.apromore.plugin.portal.logfilter;

import org.apromore.plugin.portal.PortalContext;
import org.apromore.plugin.portal.PortalLoggerFactory;
import org.apromore.portal.model.LogSummaryType;
import org.apromore.portal.model.SummaryType;
import org.apromore.portal.model.VersionSummaryType;
import org.springframework.beans.factory.annotation.Autowired;
import org.apromore.plugin.portal.logfilter.generic.LogFilterClient;
import org.apromore.plugin.portal.logfilter.generic.LogFilterResponse;
import org.apromore.apmlog.filter.rules.LogFilterRule;
import org.apromore.apmlog.filter.rules.LogFilterRuleImpl;
import org.apromore.apmlog.filter.rules.RuleValue;
import org.apromore.apmlog.filter.types.Choice;
import org.apromore.apmlog.filter.types.FilterType;
import org.apromore.apmlog.filter.types.Inclusion;
import org.apromore.apmlog.filter.types.OperationType;
import org.apromore.apmlog.filter.types.Section;
import org.apromore.apmlog.filter.PLog;
import org.apromore.apmlog.filter.APMLogFilter;

import org.apromore.apmlog.APMLog;
import org.apromore.apmlog.ATrace;
import org.apromore.apmlog.logobjects.ActivityInstance;
import org.apromore.apmlog.exceptions.EmptyInputException;


import org.slf4j.Logger;
import org.zkoss.zk.ui.Component;
import org.zkoss.zk.ui.event.Events;
import org.zkoss.zk.ui.select.SelectorComposer;
import org.zkoss.zk.ui.select.annotation.Wire;
import org.zkoss.zk.ui.select.annotation.Listen;
import org.zkoss.zk.ui.Executions;
import org.zkoss.zk.ui.Sessions;
import org.zkoss.zk.ui.util.Clients;
import org.zkoss.zul.*;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.ArrayList;
import java.util.List;
import java.util.HashSet;
import java.util.Set;
import java.util.Arrays;

import java.util.*;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * –ö–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä –¥–ª—è —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–≥–æ –æ–∫–Ω–∞ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –ª–æ–≥–æ–≤ Apromore
 */
public class AdvancedLogFilterController extends SelectorComposer<Component> {

    private static final Logger LOGGER = PortalLoggerFactory.getLogger(AdvancedLogFilterController.class);

    // Main window (bind to ZUL id 'logFilterWindow')
    @Wire("#logFilterWindow, #advancedLogFilterWindow") private Window advancedLogFilterWindow;
    
    // Log information display
    @Wire private Label logNameLabel;
    @Wire private Label eventCountLabel;
    @Wire private Label caseCountLabel;

    // Navigation buttons
    @Wire private Button caseAttributeNav;
    @Wire private Button caseVariantNav;
    @Wire private Button caseIdNav;
    @Wire private Button timeframeNav;
    @Wire private Button performanceNav;
    @Wire private Button pathNav;
    @Wire private Button reworkNav;
    @Wire private Button blocksNav;
    @Wire private Button eventAttributeNav;
    @Wire private Button eventTimeframeNav;
    @Wire private Button eventFrequencyNav;
    @Wire private Button eventPerformanceNav;
    @Wire private Button eventPathNav;
    @Wire private Button eventBetweenNav;

    // Accumulated descriptions passed from Criteria window
    private List<String> criteriaDescriptionsFromArgs = new java.util.ArrayList<>();

    // Content panels
    @Wire private Div caseAttributePanel;
    @Wire private Div caseIdPanel;
    @Wire private Div caseVariantPanel;
    @Wire private Div timeframePanel;
    @Wire private Div performancePanel;
    @Wire private Div pathPanel;
    @Wire private Div reworkPanel;
    @Wire private Div blocksPanel;

    // Case Attribute Filter components
    @Wire private Radiogroup caseAttributeCondition;
    @Wire private Radiogroup primaryAttributeType;
    @Wire private Combobox primaryAttributeCombo;
    @Wire private Checkbox useSecondaryAttribute;
    @Wire private Radiogroup secondaryAttributeType;
    @Wire private Combobox secondaryAttributeCombo;
    @Wire private Radiogroup matchingCondition;
    @Wire private Textbox valueSearchBox;
    @Wire private Listbox attributeValuesList;
    @Wire private Label caseAttributeStats;

    // Case ID Filter components
    @Wire private Radiogroup caseIdCondition;
    @Wire private Listbox caseIdValuesList;
    @Wire private Label caseIdStats;

    // Timeframe Filter components
    @Wire private Radiogroup timeframeCondition;



    @Wire private Label timeAxisLabel;
    @Wire private Label fromTimeLabel;
    @Wire private Label toTimeLabel;
    @Wire private Label durationLabel;
    @Wire private Button applyFiltersBtnTimeframe;
    @Wire private Label timeRangeDisplay;
    @Wire private Label caseCountDisplay;
    @Wire private Datebox fromDate;
    @Wire private Datebox toDate;
    
    // Containment icons
    @Wire private Div startInIcon;
    @Wire private Div endInIcon;
    @Wire private Div containedInIcon;
    @Wire private Div activeInIcon;


    // Control buttons
    @Wire private Button cancelBtn;
    @Wire private Button applyFiltersBtn;
    @Wire private Button applyFiltersBtnCaseAttribute;
    @Wire private Button applyFiltersBtnCaseId;

    // Pagination buttons for attributes
    @Wire private Button firstPageBtn;
    @Wire private Button prevPageBtn;
    @Wire private Button nextPageBtn;
    @Wire private Button lastPageBtn;
    @Wire private Label pageLabel;
    @Wire private Label pageInfo;
    @Wire private Label totalInfo;

    // Pagination buttons for Case ID
    @Wire private Button caseIdFirstPageBtn;
    @Wire private Button caseIdPrevPageBtn;
    @Wire private Button caseIdNextPageBtn;
    @Wire private Button caseIdLastPageBtn;
    @Wire private Label caseIdPageLabel;
    @Wire private Label caseIdPageInfo;
    @Wire private Label caseIdTotalInfo;

    // Internal state
    private String currentFilter = "caseAttribute";
    
    // Log information
    private PortalContext portalContext;
    private LogSummaryType selectedLog;
    private String logName;
    private Integer logId;
    
    // Process Discoverer integration
    private LogFilterClient logFilterClient;
    private APMLog apmLog;
    private List<LogFilterRule> currentCriteria;
    
    // Pagination state
    private static final int ITEMS_PER_PAGE = 100;
    private int currentAttributePage = 1;
    private int currentCaseIdPage = 1;
    private List<String> allAttributeValues = new ArrayList<>();
    private List<String> allCaseIdValues = new ArrayList<>();
    
    @Autowired(required = false)
    private Object processDiscovererPlugin;

    // Predefined timeframes UI
    @Wire private Checkbox usePredefinedTimeframes;
    @Wire private Hlayout predefinedTimeframesLayout;
    @Wire private Combobox predefinedTimeframeType;
    @Wire private Button intervalsBtn;

    // State for predefined timeframes
    private String selectedPredefinedType;
    private List<String> selectedPredefinedIntervals = new ArrayList<>();

    // Performance filter UI (Cases)
    @Wire private Radiogroup performanceCondition;
    @Wire private Combobox performanceMeasure;
    @Wire private Intbox perfGteValue;
    @Wire private Combobox perfGteUnit;
    @Wire private Intbox perfLteValue;
    @Wire private Combobox perfLteUnit;
    @Wire private Button applyFiltersBtnPerformance;
    @Wire private Button filterTopLeftBtn;
    @Wire private Div perfGteRow;
    @Wire private Div perfLteRow;
    @Wire private Div perfLenRow;
    @Wire private Intbox perfLenFrom;
    @Wire private Intbox perfLenTo;

    @Override
    public void doAfterCompose(Component comp) throws Exception {
        super.doAfterCompose(comp);
        LOGGER.info("AdvancedLogFilterController initialized");
        
        extractLogInformation();
        updateLogInfoDisplay();
        initializeNavigation();
        initializeControlButtons();
        loadLogData();
        initializeTimeframeFilter();
        configureTopLeftButton();
        
        // Show default panel
        showPanel("caseAttribute");
    }
    
    /**
     * Event handler for primary attribute selection change
     */
    @Listen("onChange = #primaryAttributeCombo")
    public void onPrimaryAttributeChange() {
        try {
            LOGGER.info("üîÑ –ò–∑–º–µ–Ω–µ–Ω –≤—ã–±—Ä–∞–Ω–Ω—ã–π –∞—Ç—Ä–∏–±—É—Ç, –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏—è...");
            loadAttributeValuesForLog();
        } catch (Exception e) {
            LOGGER.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –∞—Ç—Ä–∏–±—É—Ç–∞", e);
        }
    }
    
    /**
     * Event handler for primary attribute type change (Event vs Case)
     */
    @Listen("onChange = #primaryAttributeType")
    public void onPrimaryAttributeTypeChange() {
        try {
            LOGGER.info("üîÑ –ò–∑–º–µ–Ω–µ–Ω —Ç–∏–ø –∞—Ç—Ä–∏–±—É—Ç–∞ (Event/Case), –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ–º –∞—Ç—Ä–∏–±—É—Ç—ã...");
            
            // Debug: Log the current selection
            if (primaryAttributeType != null && primaryAttributeType.getSelectedItem() != null) {
                String selectedType = primaryAttributeType.getSelectedItem().getValue();
                LOGGER.info("üîß –í—ã–±—Ä–∞–Ω–Ω—ã–π —Ç–∏–ø: {}", selectedType);
            } else {
                LOGGER.warn("‚ö†Ô∏è primaryAttributeType –∏–ª–∏ selectedItem –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω");
            }
            
            loadAvailableAttributesFromLog(); // Reload attributes based on new type
            loadAttributeValuesForLog(); // Reload values for the new attribute type
            
            LOGGER.info("‚úÖ –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∞ –∞—Ç—Ä–∏–±—É—Ç–æ–≤ –∑–∞–≤–µ—Ä—à–µ–Ω–∞");
        } catch (Exception e) {
            LOGGER.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Ç–∏–ø–∞ –∞—Ç—Ä–∏–±—É—Ç–∞", e);
        }
    }
    
    /**
     * Alternative event handler for radio button clicks
     */
    @Listen("onCheck = #primaryAttributeType radio")
    public void onPrimaryAttributeTypeRadioClick() {
        try {
            LOGGER.info("üîÑ Radio button clicked –≤ primaryAttributeType");
            onPrimaryAttributeTypeChange();
        } catch (Exception e) {
            LOGGER.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∫–ª–∏–∫–∞ radio button", e);
        }
    }


    /**
     * Applying filters button in timeframe panel
     */
    @Listen("onClick = #applyFiltersBtnTimeframe")
    public void onApplyTimeframeFiltersClick() {
        try {
            LOGGER.info("Applying timeframe filters...");
            currentFilter = "timeframe";
            applyFiltersAndRedirect();
        } catch (Exception e) {
            LOGGER.error("Error applying timeframe filters", e);
        }
    }
    
    /**
     * Event handler for START IN icon click
     */
    @Listen("onClick = #startInIcon")
    public void onStartInIconClick() {
        try {
            if (containmentLocked) return;
            setContainmentIcon("start");
            // Disable To? No, for start we ignore To input? We disable fromDate? We disable toDate per requirement
            if (toDate != null) {
                toDate.setDisabled(true);
            }
            if (fromDate != null) {
                fromDate.setDisabled(false);
            }
            // last occurred event date becomes the end of the timeframe
            if (apmLog != null && toDate != null) {
                toDate.setValue(new Date(apmLog.getEndTime()));
            }
            LOGGER.info("Containment set to: start in");
        } catch (Exception e) {
            LOGGER.error("Error setting start in containment", e);
        }
    }

    /**
     * Event handler for END IN icon click
     */
    @Listen("onClick = #endInIcon")
    public void onEndInIconClick() {
        try {
            if (containmentLocked) return;
            setContainmentIcon("end");
            //Ignore start date and disable it and set to log's first occured start boundary
            if (fromDate != null) {
                fromDate.setDisabled(true);
            }
            if (toDate != null) {
                toDate.setDisabled(false);
            }
            if (apmLog != null && fromDate != null) {
                fromDate.setValue(new Date(apmLog.getStartTime()));
            }
            LOGGER.info("Containment set to: end in");
        } catch (Exception e) {
            LOGGER.error("Error setting end in containment", e);
        }
    }

    /**
     * event handler for CONTAINED IN icon click
     */
    @Listen("onClick = #containedInIcon")
    public void onContainedInIconClick() {
        try {
            // take both dates from user
            if (containmentLocked) return;
            setContainmentIcon("contained");
            if (fromDate != null) fromDate.setDisabled(false);
            if (toDate != null) toDate.setDisabled(false);
            LOGGER.info("Containment set to: contained in");
        } catch (Exception e) {
            LOGGER.error("Error setting contained in containment", e);
        }
    }

    /**
     * Event handler for ACTIVE IN icon click
     */
    @Listen("onClick = #activeInIcon")
    public void onActiveInIconClick() {
        try {
            // both dates are taken from user
            if (containmentLocked) return;
            setContainmentIcon("active");
            if (fromDate != null) fromDate.setDisabled(false);
            if (toDate != null) toDate.setDisabled(false);
            LOGGER.info("Containment set to: active in");
        } catch (Exception e) {
            LOGGER.error("Error setting active in containment", e);
        }
    }

    /**
     * –ò–∑–≤–ª–µ–∫–∞–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≤—ã–±—Ä–∞–Ω–Ω–æ–º –ª–æ–≥–µ –∏–∑ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ ZK
     */
    private void extractLogInformation() {
        try {
            Map<?, ?> args = Executions.getCurrent().getArg();
            if (args != null) {
                this.portalContext = (PortalContext) args.get("portalContext");
                this.selectedLog = (LogSummaryType) args.get("selectedLog");
                this.logName = (String) args.get("logName");
                this.logId = (Integer) args.get("logId");
                
                // –ü–æ–ª—É—á–∞–µ–º APMLog
                Object apmLogObj = args.get("apmLog");
                if (apmLogObj instanceof APMLog) {
                    apmLog = (APMLog) apmLogObj;
                    LOGGER.info("APMLog –ø–æ–ª—É—á–µ–Ω: {} —Ç—Ä–∞—Å—Å", apmLog.getTraces().size());
                }
                
                // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–µ –∫—Ä–∏—Ç–µ—Ä–∏–∏ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
                Object criteriaObj = args.get("currentCriteria");
                if (criteriaObj instanceof List) {
                    currentCriteria = (List<LogFilterRule>) criteriaObj;
                    LOGGER.info("–ö—Ä–∏—Ç–µ—Ä–∏–∏ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –ø–æ–ª—É—á–µ–Ω—ã: {} –ø—Ä–∞–≤–∏–ª", currentCriteria.size());
                }
                
                // –ü–æ–ª—É—á–∞–µ–º LogFilterClient
                Object clientObj = args.get("logFilterClient");
                if (clientObj instanceof LogFilterClient) {
                    logFilterClient = (LogFilterClient) clientObj;
                    LOGGER.info("LogFilterClient –ø–æ–ª—É—á–µ–Ω");
                }
                // Support receiving accumulated rules from criteria window
                Object passedRules = args.get("criteriaRules");
                if (passedRules instanceof java.util.List) {
                    //noinspection unchecked
                    currentCriteria = (java.util.List<LogFilterRule>) passedRules;
                    LOGGER.info("–ü–æ–ª—É—á–µ–Ω—ã –Ω–∞–∫–æ–ø–ª–µ–Ω–Ω—ã–µ –∫—Ä–∏—Ç–µ—Ä–∏–∏: {} –ø—Ä–∞–≤–∏–ª", currentCriteria.size());
                }
                Object passedDescs = args.get("criteriaDescriptions");
                if (passedDescs instanceof java.util.List) {
                    //noinspection unchecked
                    criteriaDescriptionsFromArgs = new java.util.ArrayList<>((java.util.List<String>) passedDescs);
                    LOGGER.info("–ü–æ–ª—É—á–µ–Ω—ã –Ω–∞–∫–æ–ø–ª–µ–Ω–Ω—ã–µ –æ–ø–∏—Å–∞–Ω–∏—è –∫—Ä–∏—Ç–µ—Ä–∏–µ–≤: {}", criteriaDescriptionsFromArgs.size());
                }
                
                LOGGER.info("–ü–æ–ª—É—á–µ–Ω–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ª–æ–≥–µ: {} (ID: {})", logName, logId);
                LOGGER.info("–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ª–æ–≥–µ –∏–∑–≤–ª–µ—á–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ");
            } else {
                LOGGER.warn("–ê—Ä–≥—É–º–µ–Ω—Ç—ã –Ω–µ –ø–µ—Ä–µ–¥–∞–Ω—ã, –∏—Å–ø–æ–ª—å–∑—É–µ–º –∑–∞–≥–ª—É—à–µ—á–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ");
                this.logName = "Sample Log";
                this.logId = -1;
            }
        } catch (Exception e) {
            LOGGER.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–∑–≤–ª–µ—á–µ–Ω–∏–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –ª–æ–≥–µ", e);
            this.logName = "Unknown Log";
            this.logId = -1;
        }
    }

    /**
     * Update log information display components
     */
    private void updateLogInfoDisplay() {
        try {
            // Update window title
                    if (advancedLogFilterWindow != null && logName != null && !logName.isEmpty()) {
            advancedLogFilterWindow.setTitle("Filter log: " + logName);
                LOGGER.info("–ó–∞–≥–æ–ª–æ–≤–æ–∫ –æ–∫–Ω–∞ –æ–±–Ω–æ–≤–ª–µ–Ω: Filter log: {}", logName);
            }
            
            // Update log name
            if (logNameLabel != null) {
                if (logName != null && !logName.isEmpty()) {
                    logNameLabel.setValue(logName);
                    LOGGER.info("–û—Ç–æ–±—Ä–∞–∂–µ–Ω–æ –∏–º—è –ª–æ–≥–∞: {}", logName);
                } else {
                    logNameLabel.setValue("Unknown Log");
                    LOGGER.warn("–ò–º—è –ª–æ–≥–∞ –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ");
                }
            } else {
                LOGGER.warn("logNameLabel –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω");
            }

            // Update event and case counts
            if (selectedLog != null && logId != null && logId > 0) {
                try {
                    // –ü–æ–ª—É—á–∞–µ–º —Ä–µ–∞–ª—å–Ω—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ª–æ–≥–∞
                    loadRealLogStatistics();
                } catch (Exception e) {
                    LOGGER.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ª–æ–≥–∞", e);
                    // Fallback to default values
                    if (eventCountLabel != null) {
                        eventCountLabel.setValue("Loading events...");
                    }
                    if (caseCountLabel != null) {
                        caseCountLabel.setValue("Loading cases...");
                    }
                }
            } else {
                //real data from the log
                if (apmLog != null) {
                    int eventCount = 0;
                    int caseCount = apmLog.getTraces().size();
                    for (ATrace trace : apmLog.getTraces()) {
                        eventCount += trace.getActivityInstances().size();
                    }
                    if (eventCountLabel != null) {
                        eventCountLabel.setValue(String.format("%,d events", eventCount));
                    }
                    if (caseCountLabel != null) {
                        caseCountLabel.setValue(String.format("%,d cases", caseCount));
                    }
                    LOGGER.info("Loaded real statistics for log '{}': {} events, {} cases", logName, eventCount, caseCount);
                } else {
                    if (eventCountLabel != null) {
                        eventCountLabel.setValue("N/A");
                    }
                    if (caseCountLabel != null) {
                        caseCountLabel.setValue("N/A");
                    }
                    LOGGER.warn("Unable to load real statistics for the log; APMLog is null");
                }
            }

        } catch (Exception e) {
            LOGGER.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –ª–æ–≥–µ", e);
            
            // Fallback values
            if (logNameLabel != null) logNameLabel.setValue("Error loading log name");
            if (eventCountLabel != null) eventCountLabel.setValue("N/A");
            if (caseCountLabel != null) caseCountLabel.setValue("N/A");
        }
    }

    /**
     * Load real log statistics from the selected log
     */
    private void loadRealLogStatistics() {
        try {
            if (apmLog != null) {
                LOGGER.info("–ó–∞–≥—Ä—É–∂–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ª–æ–≥–∞ –∏–∑ APMLog");
 
                int eventCount = 0;
                int caseCount = apmLog.getTraces().size();
         
                for (ATrace trace : apmLog.getTraces()) {
                    eventCount += trace.getActivityInstances().size();
                }

                if (eventCountLabel != null) {
                    eventCountLabel.setValue(String.format("%,d events", eventCount));
                }
                if (caseCountLabel != null) {
                    caseCountLabel.setValue(String.format("%,d cases", caseCount));
                }
                
                LOGGER.info("–í—ã—á–∏—Å–ª–µ–Ω–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –¥–ª—è –ª–æ–≥–∞ '{}' (ID: {}): {} events, {} cases", 
                           logName, logId, eventCount, caseCount);
                
            } else if (logId != null && logId > 0) {
                LOGGER.warn("APMLog –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º –∑–∞–≥–ª—É—à–µ—á–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ");
                if (eventCountLabel != null) {
                    eventCountLabel.setValue("Loading events...");
                }
                if (caseCountLabel != null) {
                    caseCountLabel.setValue("Loading cases...");
                }
            } else {
                LOGGER.warn("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π ID –ª–æ–≥–∞: {}", logId);
                if (eventCountLabel != null) {
                    eventCountLabel.setValue("N/A");
                }
                if (caseCountLabel != null) {
                    caseCountLabel.setValue("N/A");
                }
            }

        } catch (Exception e) {
            LOGGER.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ª–æ–≥–∞", e);
            
            // Fallback values
            if (eventCountLabel != null) {
                eventCountLabel.setValue("Error loading events");
            }
            if (caseCountLabel != null) {
                caseCountLabel.setValue("Error loading cases");
            }
        }
    }

    /**
     * Load real log data for filtering
     */
    private void loadLogData() {
        try {
            if (selectedLog != null && logId != null && logId > 0) {
                LOGGER.info("–ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ª–æ–≥–∞: {} (ID: {})", logName, logId);
                loadAttributeData();
                loadCaseIdData();
                updateStatistics();
                
                LOGGER.info("–î–∞–Ω–Ω—ã–µ –ª–æ–≥–∞ –∑–∞–≥—Ä—É–∂–µ–Ω—ã —É—Å–ø–µ—à–Ω–æ");
            } else {
                LOGGER.warn("–ò—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –∑–∞–≥–ª—É—à–µ—á–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ - –ª–æ–≥ –Ω–µ –≤—ã–±—Ä–∞–Ω");
                loadSampleData();
            }
        } catch (Exception e) {
            LOGGER.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –¥–∞–Ω–Ω—ã—Ö –ª–æ–≥–∞", e);
            loadSampleData();
        }
    }

    /**
     * Load attribute values from the selected log
     */
    private void loadAttributeData() {
        try {
            LOGGER.info("üîÑ === –ù–ê–ß–ê–õ–û loadAttributeData() ===");
            
            if (attributeValuesList != null) {
                LOGGER.info("‚úÖ attributeValuesList –¥–æ—Å—Ç—É–ø–µ–Ω");
                attributeValuesList.getItems().clear();
                
                // –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ –∑–∞–≥—Ä—É–∂–∞–µ–º –∞—Ç—Ä–∏–±—É—Ç—ã –∏–∑ –ª–æ–≥–∞
                if (primaryAttributeCombo != null) {
                    LOGGER.info("‚úÖ primaryAttributeCombo –¥–æ—Å—Ç—É–ø–µ–Ω");
                    LOGGER.info("üîß –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤ primaryAttributeCombo –¥–æ –∑–∞–≥—Ä—É–∑–∫–∏: {}", primaryAttributeCombo.getItemCount());
                    
                    loadAvailableAttributesFromLog();
                    
                    LOGGER.info("üîß –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤ primaryAttributeCombo –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏: {}", primaryAttributeCombo.getItemCount());
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∞—Ç—Ä–∏–±—É—Ç—ã –∑–∞–≥—Ä—É–∂–µ–Ω—ã –∏ –µ—Å—Ç—å –≤—ã–±—Ä–∞–Ω–Ω—ã–π
                    if (primaryAttributeCombo.getItemCount() > 0) {
                        LOGGER.info("‚úÖ –ê—Ç—Ä–∏–±—É—Ç—ã –∑–∞–≥—Ä—É–∂–µ–Ω—ã, –∑–∞–≥—Ä—É–∂–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –∞—Ç—Ä–∏–±—É—Ç–∞...");
                        
                        Comboitem selectedItem = primaryAttributeCombo.getSelectedItem();
                        if (selectedItem != null) {
                            LOGGER.debug("‚úÖ –í—ã–±—Ä–∞–Ω–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç: " + selectedItem.getValue());
                        } else {
                            LOGGER.warn("‚ö†Ô∏è –ù–µ—Ç –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏ –∞—Ç—Ä–∏–±—É—Ç–æ–≤");
                        }
                        
                        // Ensure a selection exists before loading values
                        if (primaryAttributeCombo.getSelectedItem() == null && primaryAttributeCombo.getItemCount() > 0) {
                            primaryAttributeCombo.setSelectedIndex(0);
                        }
                        loadAttributeValuesForLog();
                    } else {
                        LOGGER.warn("‚ö†Ô∏è –ê—Ç—Ä–∏–±—É—Ç—ã –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –∑–∞–≥—Ä—É–∑–∫—É –∑–Ω–∞—á–µ–Ω–∏–π");
                    }
                } else {
                    LOGGER.warn("‚ö†Ô∏è primaryAttributeCombo –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω");
                }
            } else {
                LOGGER.warn("‚ö†Ô∏è attributeValuesList –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω");
            }
            
            LOGGER.info("üîÑ === –ö–û–ù–ï–¶ loadAttributeData() ===");
        } catch (Exception e) {
            LOGGER.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –¥–∞–Ω–Ω—ã—Ö –∞—Ç—Ä–∏–±—É—Ç–æ–≤", e);
        }
    }
    
    /**
     * Load available attributes from the current log
     */
    private void loadAvailableAttributesFromLog() {
        try {
            if (primaryAttributeCombo == null) {
                LOGGER.warn("primaryAttributeCombo –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω");
                return;
            }
            
            LOGGER.info("–ó–∞–≥—Ä—É–∂–∞–µ–º –¥–æ—Å—Ç—É–ø–Ω—ã–µ –∞—Ç—Ä–∏–±—É—Ç—ã –∏–∑ –ª–æ–≥–∞: {} (ID: {})", logName, logId);
            
            // –û—á–∏—â–∞–µ–º –∫–æ–º–±–æ–±–æ–∫—Å
            primaryAttributeCombo.getItems().clear();
            
            // Get the selected attribute type (Event vs Case)
            String selectedAttributeType = "event"; // default to event
            if (primaryAttributeType != null && primaryAttributeType.getSelectedItem() != null) {
                selectedAttributeType = primaryAttributeType.getSelectedItem().getValue();
            }
            
            LOGGER.info("üîß –í—ã–±—Ä–∞–Ω–Ω—ã–π —Ç–∏–ø –∞—Ç—Ä–∏–±—É—Ç–∞: {}", selectedAttributeType);
            
            if (apmLog != null) {
                LOGGER.info("üîß APMLog –¥–æ—Å—Ç—É–ø–µ–Ω, –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç—Ä–∞—Å—Å: {}", apmLog.getTraces().size());
                
                // –°–æ–±–∏—Ä–∞–µ–º –∞—Ç—Ä–∏–±—É—Ç—ã –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞
                Set<String> availableAttributes = new HashSet<>();
                
                if ("event".equals(selectedAttributeType)) {
                    // –°–æ–±–∏—Ä–∞–µ–º –∞—Ç—Ä–∏–±—É—Ç—ã –∏–∑ —ç–∫–∑–µ–º–ø–ª—è—Ä–æ–≤ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ (event attributes only)
                    int eventAttributeCount = 0;
                    int totalActivityInstances = 0;
                    Set<String> standardAttributesFound = new HashSet<>();
                    
                    for (ATrace trace : apmLog.getTraces()) {
                        totalActivityInstances += trace.getActivityInstances().size();
                        for (ActivityInstance activityInstance : trace.getActivityInstances()) {
                            if (activityInstance.getAttributes() != null) {
                                eventAttributeCount += activityInstance.getAttributes().size();
                                
                                // Add event attributes only, exclude case attributes
                                for (String attrKey : activityInstance.getAttributes().keySet()) {
                                    // Skip concept:name since we have Activity as the user-friendly option
                                    if (!"concept:name".equals(attrKey)) {
                                        // Only add event-level attributes, not case attributes
                                        if (!attrKey.equals("concept:case:id") && 
                                            !attrKey.startsWith("case:")) {
                                            availableAttributes.add(attrKey);
                                        }
                                    }
                                }
                                
                                // Check if standard event attributes exist in this activity instance
                                if (activityInstance.getAttributes().containsKey("concept:name")) {
                                    standardAttributesFound.add("concept:name");
                                }
                                if (activityInstance.getAttributes().containsKey("org:resource")) {
                                    standardAttributesFound.add("org:resource");
                                }
                                if (activityInstance.getAttributes().containsKey("lifecycle:transition")) {
                                    standardAttributesFound.add("lifecycle:transition");
                                }
                                if (activityInstance.getAttributes().containsKey("time:timestamp")) {
                                    standardAttributesFound.add("time:timestamp");
                                }
                            }
                        }
                    }
                    
                    // Always add Activity as the main option (maps to concept:name internally)
                    availableAttributes.add("Activity");
                    LOGGER.info("üîß –î–æ–±–∞–≤–ª–µ–Ω –æ—Å–Ω–æ–≤–Ω–æ–π –∞—Ç—Ä–∏–±—É—Ç –¥–ª—è Event: Activity");
                    
                    // Only add standard attributes if they actually exist in the log
                    if (standardAttributesFound.contains("org:resource")) {
                        availableAttributes.add("org:resource");
                        LOGGER.info("üîß –î–æ–±–∞–≤–ª–µ–Ω —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –∞—Ç—Ä–∏–±—É—Ç: org:resource");
                    }
                    if (standardAttributesFound.contains("lifecycle:transition")) {
                        availableAttributes.add("lifecycle:transition");
                        LOGGER.info("üîß –î–æ–±–∞–≤–ª–µ–Ω —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –∞—Ç—Ä–∏–±—É—Ç: lifecycle:transition");
                    }
                    if (standardAttributesFound.contains("time:timestamp")) {
                        availableAttributes.add("time:timestamp");
                        LOGGER.info("üîß –î–æ–±–∞–≤–ª–µ–Ω —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –∞—Ç—Ä–∏–±—É—Ç: time:timestamp");
                    }
                    
                    LOGGER.info("üîß –ù–∞–π–¥–µ–Ω–æ {} event –∞—Ç—Ä–∏–±—É—Ç–æ–≤ –≤ {} —ç–∫–∑–µ–º–ø–ª—è—Ä–∞—Ö –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏", eventAttributeCount, totalActivityInstances);
                    LOGGER.info("üîß –ù–∞–π–¥–µ–Ω–æ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã—Ö –∞—Ç—Ä–∏–±—É—Ç–æ–≤: {}", standardAttributesFound);
                    
                } else {
                    // For Case attributes - only collect case-level attributes
                    availableAttributes.add("concept:case:id");
                    LOGGER.info("üîß –î–æ–±–∞–≤–ª–µ–Ω—ã —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ case –∞—Ç—Ä–∏–±—É—Ç—ã");
                    
                    // –°–æ–±–∏—Ä–∞–µ–º –∞—Ç—Ä–∏–±—É—Ç—ã –∏–∑ —Ç—Ä–∞—Å—Å (case attributes only)
                    int caseAttributeCount = 0;
                    for (ATrace trace : apmLog.getTraces()) {
                        if (trace.getAttributes() != null) {
                            caseAttributeCount += trace.getAttributes().size();
                            // Only add case-level attributes, not event attributes
                            for (String attrKey : trace.getAttributes().keySet()) {
                                // Filter out event attributes that might be stored at trace level
                                if (!attrKey.startsWith("event:") && 
                                    !attrKey.equals("concept:name") && 
                                    !attrKey.equals("org:resource") && 
                                    !attrKey.equals("lifecycle:transition") && 
                                    !attrKey.equals("time:timestamp")) {
                                    availableAttributes.add(attrKey);
                                }
                            }
                        }
                    }
                    LOGGER.info("üîß –ù–∞–π–¥–µ–Ω–æ {} case –∞—Ç—Ä–∏–±—É—Ç–æ–≤ –≤ {} —Ç—Ä–∞—Å—Å–∞—Ö", caseAttributeCount, apmLog.getTraces().size());
                }
                
                // –°–æ—Ä—Ç–∏—Ä—É–µ–º –∞—Ç—Ä–∏–±—É—Ç—ã –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞
                List<String> sortedAttributes = new ArrayList<>(availableAttributes);
                Collections.sort(sortedAttributes);
                
                LOGGER.info("üîß –í—Å–µ–≥–æ —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –∞—Ç—Ä–∏–±—É—Ç–æ–≤ –¥–ª—è —Ç–∏–ø–∞ '{}': {}", selectedAttributeType, sortedAttributes.size());
                LOGGER.info("üîß –°–ø–∏—Å–æ–∫ –∞—Ç—Ä–∏–±—É—Ç–æ–≤: {}", sortedAttributes);
                
                // –î–æ–±–∞–≤–ª—è–µ–º –∞—Ç—Ä–∏–±—É—Ç—ã –≤ –∫–æ–º–±–æ–±–æ–∫—Å
                for (String attribute : sortedAttributes) {
                    primaryAttributeCombo.appendItem(attribute);
                }
                
                // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º Activity –∫–∞–∫ –≤—ã–±—Ä–∞–Ω–Ω—ã–π –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –¥–ª—è Event attributes
                if ("event".equals(selectedAttributeType) && sortedAttributes.contains("Activity")) {
                    // Find the index of "Activity" and select it
                    for (int i = 0; i < primaryAttributeCombo.getItemCount(); i++) {
                        if ("Activity".equals(primaryAttributeCombo.getItems().get(i).getValue())) {
                            primaryAttributeCombo.setSelectedIndex(i);
                            LOGGER.info("‚úÖ –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω Activity –∫–∞–∫ –≤—ã–±—Ä–∞–Ω–Ω—ã–π –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é");
                            break;
                        }
                    }
                } else if (sortedAttributes.size() > 0) {
                    // Fallback to first attribute if Activity is not available
                    primaryAttributeCombo.setSelectedIndex(0);
                    LOGGER.info("‚úÖ –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –ø–µ—Ä–≤—ã–π –∞—Ç—Ä–∏–±—É—Ç –∫–∞–∫ –≤—ã–±—Ä–∞–Ω–Ω—ã–π: {}", sortedAttributes.get(0));
                }
                
                LOGGER.info("‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω–æ {} –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∞—Ç—Ä–∏–±—É—Ç–æ–≤ –¥–ª—è –ª–æ–≥–∞: {}", sortedAttributes.size(), logName);
                
            } else {
                LOGGER.warn("‚ö†Ô∏è APMLog –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –∞—Ç—Ä–∏–±—É—Ç—ã");
                // Fallback to standard attributes based on selected type
                if ("event".equals(selectedAttributeType)) {
                    primaryAttributeCombo.appendItem("Activity");
                    // Note: Standard attributes are only added if they exist in the actual log data
                } else {
                    primaryAttributeCombo.appendItem("concept:case:id");
                }
                primaryAttributeCombo.setSelectedIndex(0);
                LOGGER.info("‚úÖ –î–æ–±–∞–≤–ª–µ–Ω—ã —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –∞—Ç—Ä–∏–±—É—Ç—ã (fallback) –¥–ª—è —Ç–∏–ø–∞: {}", selectedAttributeType);
            }
            
        } catch (Exception e) {
            LOGGER.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∞—Ç—Ä–∏–±—É—Ç–æ–≤ –∏–∑ –ª–æ–≥–∞: {}", logName, e);
            // Fallback to standard attributes
            if (primaryAttributeType != null && primaryAttributeType.getSelectedItem() != null && 
                "event".equals(primaryAttributeType.getSelectedItem().getValue())) {
                primaryAttributeCombo.appendItem("Activity");
            } else {
                primaryAttributeCombo.appendItem("concept:case:id");
            }
            primaryAttributeCombo.setSelectedIndex(0);
        }
    }

    /**
     * Load attribute values based on the selected log
     */
    private void loadAttributeValuesForLog() {
        try {
            if (attributeValuesList == null) {
                LOGGER.warn("‚ö†Ô∏è attributeValuesList –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω");
                return;
            }

            LOGGER.info("üîÑ –ó–∞–≥—Ä—É–∂–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –∞—Ç—Ä–∏–±—É—Ç–∞ –¥–ª—è –ª–æ–≥–∞: {} (ID: {})", logName, logId);

            // –û—á–∏—â–∞–µ–º —Å–ø–∏—Å–æ–∫
            attributeValuesList.getItems().clear();
            allAttributeValues.clear();

            if (apmLog != null && primaryAttributeCombo != null) {
                // –ü–æ–ª—É—á–∞–µ–º –≤—ã–±—Ä–∞–Ω–Ω—ã–π –∞—Ç—Ä–∏–±—É—Ç
                Comboitem selectedItem = primaryAttributeCombo.getSelectedItem();
                if (selectedItem == null) {
                    LOGGER.warn("‚ö†Ô∏è –ù–µ—Ç –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –≤ primaryAttributeCombo");
                    if (primaryAttributeCombo.getItemCount() > 0) {
                        primaryAttributeCombo.setSelectedIndex(0);
                        selectedItem = primaryAttributeCombo.getSelectedItem();
                    }
                    if (selectedItem == null) {
                        return;
                    }
                }

                String selectedAttribute = (selectedItem.getValue() != null) ? String.valueOf(selectedItem.getValue()) : selectedItem.getLabel();
                if (selectedAttribute == null || selectedAttribute.isEmpty()) {
                    LOGGER.warn("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –≤—ã–±—Ä–∞–Ω–Ω—ã–π –∞—Ç—Ä–∏–±—É—Ç (value/label –ø—É—Å—Ç—ã)");
                    return;
                }
                LOGGER.info("üîß –í—ã–±—Ä–∞–Ω–Ω—ã–π –∞—Ç—Ä–∏–±—É—Ç: {}", selectedAttribute);
                
                // –ü–æ–ª—É—á–∞–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –∞—Ç—Ä–∏–±—É—Ç–∞ –∏–∑ APMLog
                Map<String, Integer> attributeValueCounts = new HashMap<>();
                
                // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø –∞—Ç—Ä–∏–±—É—Ç–∞ (case –∏–ª–∏ event) –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞ –≤ radio button
                String selectedAttributeType = "event"; // default to event
                if (primaryAttributeType != null && primaryAttributeType.getSelectedItem() != null) {
                    selectedAttributeType = primaryAttributeType.getSelectedItem().getValue();
                }
                
                boolean isCaseAttribute = "case".equals(selectedAttributeType);
                
                LOGGER.info("üîß –¢–∏–ø –∞—Ç—Ä–∏–±—É—Ç–∞: {}", isCaseAttribute ? "CASE" : "EVENT");
                LOGGER.info("üîß –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç—Ä–∞—Å—Å –≤ –ª–æ–≥–µ: {}", apmLog.getTraces().size());
                
                if (isCaseAttribute) {
                    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º case attributes
                    LOGGER.info("üîß –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º CASE –∞—Ç—Ä–∏–±—É—Ç—ã...");
                    int foundCaseValues = 0;
                    for (ATrace trace : apmLog.getTraces()) {
                        if (trace.getAttributes() != null && trace.getAttributes().containsKey(selectedAttribute)) {
                            String value = trace.getAttributes().get(selectedAttribute).toString();
                            if (value != null && !value.isEmpty()) {
                                attributeValueCounts.put(value, attributeValueCounts.getOrDefault(value, 0) + 1);
                                foundCaseValues++;
                            }
                        }
                    }
                    LOGGER.info("üîß –ù–∞–π–¥–µ–Ω–æ {} –∑–Ω–∞—á–µ–Ω–∏–π CASE –∞—Ç—Ä–∏–±—É—Ç–∞ '{}'", foundCaseValues, selectedAttribute);
                } else {
                    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º event attributes
                    LOGGER.info("üîß –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º EVENT –∞—Ç—Ä–∏–±—É—Ç—ã...");
                    int totalActivityInstances = 0;
                    int foundEventValues = 0;
                    
                    // Special handling for Activity attribute
                    if (selectedAttribute.equals("Activity")) {
                        LOGGER.info("üîß –°–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–ª—è –∞—Ç—Ä–∏–±—É—Ç–∞ Activity...");
                        for (ATrace trace : apmLog.getTraces()) {
                            totalActivityInstances += trace.getActivityInstances().size();
                            Set<String> activitiesInTrace = new HashSet<>();
                            for (ActivityInstance activityInstance : trace.getActivityInstances()) {
                                String activityName = activityInstance.getName();
                                if (activityName != null && !activityName.isEmpty()) {
                                    activitiesInTrace.add(activityName);
                                }
                            }
                            // Count each activity once per trace (case) for statistics
                            for (String activityName : activitiesInTrace) {
                                attributeValueCounts.put(activityName, attributeValueCounts.getOrDefault(activityName, 0) + 1);
                                foundEventValues++;
                            }
                        }
                        LOGGER.info("üîß –ù–∞–π–¥–µ–Ω–æ {} —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–µ–π (–ø–æ–¥—Å—á–∏—Ç–∞–Ω–æ –ø–æ —Å–ª—É—á–∞—è–º)", attributeValueCounts.size());
                    } else {
                        // Regular event attributes
                        for (ATrace trace : apmLog.getTraces()) {
                            totalActivityInstances += trace.getActivityInstances().size();
                            for (ActivityInstance activityInstance : trace.getActivityInstances()) {
                                if (activityInstance.getAttributes() != null && 
                                    activityInstance.getAttributes().containsKey(selectedAttribute)) {
                                    String value = activityInstance.getAttributes().get(selectedAttribute).toString();
                                    if (value != null && !value.isEmpty()) {
                                        attributeValueCounts.put(value, attributeValueCounts.getOrDefault(value, 0) + 1);
                                        foundEventValues++;
                                    }
                                }
                            }
                        }
                    }
                    LOGGER.info("üîß –û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–∫–∑–µ–º–ø–ª—è—Ä–æ–≤ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏: {}", totalActivityInstances);
                    LOGGER.info("üîß –ù–∞–π–¥–µ–Ω–æ {} –∑–Ω–∞—á–µ–Ω–∏–π EVENT –∞—Ç—Ä–∏–±—É—Ç–∞ '{}'", foundEventValues, selectedAttribute);
                }
                
                LOGGER.info("üîß –ù–∞–π–¥–µ–Ω–æ {} —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π –∞—Ç—Ä–∏–±—É—Ç–∞ '{}'", attributeValueCounts.size(), selectedAttribute);
                LOGGER.info("üîß –î–µ—Ç–∞–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–π: {}", attributeValueCounts);
                
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—Å–µ –∑–Ω–∞—á–µ–Ω–∏—è –∞—Ç—Ä–∏–±—É—Ç–∞ –¥–ª—è –ø–∞–≥–∏–Ω–∞—Ü–∏–∏
                allAttributeValues.addAll(attributeValueCounts.keySet());
                // –°–æ—Ä—Ç–∏—Ä—É–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –∞—Ç—Ä–∏–±—É—Ç–∞ –ø–æ –∞–ª—Ñ–∞–≤–∏—Ç—É –±–µ–∑ —É—á–µ—Ç–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞
                allAttributeValues.sort(String::compareToIgnoreCase);
                LOGGER.info("üîß allAttributeValues –∑–∞–ø–æ–ª–Ω–µ–Ω –∏ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω: {} —ç–ª–µ–º–µ–Ω—Ç–æ–≤", allAttributeValues.size());
                
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–µ—Ä–≤—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É
                currentAttributePage = 1;
                displayAttributePage(currentAttributePage);
                
                LOGGER.info("‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω—ã {} –∑–Ω–∞—á–µ–Ω–∏–π –∞—Ç—Ä–∏–±—É—Ç–∞ '{}' –¥–ª—è –ª–æ–≥–∞: {}", 
                           attributeValueCounts.size(), selectedAttribute, logName);
                
            } else {
                LOGGER.warn("‚ö†Ô∏è APMLog –∏–ª–∏ primaryAttributeCombo –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º –∑–∞–≥–ª—É—à–µ—á–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ");
                if (apmLog == null) {
                    LOGGER.warn("‚ö†Ô∏è APMLog = null");
                }
                if (primaryAttributeCombo == null) {
                    LOGGER.warn("‚ö†Ô∏è primaryAttributeCombo = null");
                }
                // Fallback to sample data (already sorted alphabetically)
                allAttributeValues.addAll(Arrays.asList("Value A", "Value B", "Value C", "Value D", "Value E"));
                currentAttributePage = 1;
                displayAttributePage(currentAttributePage);
            }

        } catch (Exception e) {
            LOGGER.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∑–Ω–∞—á–µ–Ω–∏–π –∞—Ç—Ä–∏–±—É—Ç–∞ –¥–ª—è –ª–æ–≥–∞: {}", logName, e);
        }
    }

    /**
     * Add attribute value to the list
     */
    private void addAttributeValue(String value, int cases, double frequency) {
        try {
            if (attributeValuesList != null) {
                LOGGER.debug("üîß –°–æ–∑–¥–∞–µ–º Listitem –¥–ª—è –∑–Ω–∞—á–µ–Ω–∏—è: '{}', –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ: {}, —á–∞—Å—Ç–æ—Ç–∞: {:.2f}%", value, cases, frequency);
                
                // Get the current selected attribute name for date formatting
                String selectedAttribute = null;
                if (primaryAttributeCombo != null && primaryAttributeCombo.getSelectedItem() != null) {
                    selectedAttribute = (primaryAttributeCombo.getSelectedItem().getValue() != null) ? 
                        String.valueOf(primaryAttributeCombo.getSelectedItem().getValue()) : 
                        primaryAttributeCombo.getSelectedItem().getLabel();
                }
                
                // Format the value if it's a date
                String displayValue = formatDateValue(value, selectedAttribute);
                
                Listitem item = new Listitem();
                item.appendChild(new Listcell(displayValue));
                item.appendChild(new Listcell(String.valueOf(cases)));
                item.appendChild(new Listcell(formatFrequency(frequency)));
                
                attributeValuesList.appendChild(item);
                
                LOGGER.debug("‚úÖ Listitem –¥–æ–±–∞–≤–ª–µ–Ω –≤ —Ç–∞–±–ª–∏—Ü—É –¥–ª—è –∑–Ω–∞—á–µ–Ω–∏—è: '{}' (–æ—Ç—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–æ: '{}')", value, displayValue);
            } else {
                LOGGER.warn("‚ö†Ô∏è attributeValuesList == null –≤ addAttributeValue");
            }
        } catch (Exception e) {
            LOGGER.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –∑–Ω–∞—á–µ–Ω–∏—è –∞—Ç—Ä–∏–±—É—Ç–∞ '{}' –≤ —Ç–∞–±–ª–∏—Ü—É", value, e);
        }
    }
    
    /**
     * Format frequency with smart decimal places
     * Shows 2 decimal places when needed, but only 1 when it rounds nicely
     */
    private String formatFrequency(double frequency) {
        // Round to 2 decimal places first
        double rounded2 = Math.round(frequency * 100.0) / 100.0;
        
        // Check if it rounds to exactly 1 decimal place
        double rounded1 = Math.round(frequency * 10.0) / 10.0;
        
        if (Math.abs(rounded2 - rounded1) < 0.001) {
            // It rounds nicely to 1 decimal place
            return String.format("%.1f%%", rounded1);
        } else {
            // Need 2 decimal places for precision
            return String.format("%.2f%%", rounded2);
        }
    }
    
    /**
     * Format date values to display format "06 Nov 20, 17:27:04"
     */
    private String formatDateValue(String value, String attributeName) {
        // Check if this is a date attribute
        if (attributeName != null && (attributeName.startsWith("date_") || 
            attributeName.equals("time:timestamp") || 
            attributeName.contains("time") || 
            attributeName.contains("date"))) {
            
            try {
                // Try to parse the date value and format it
                return formatDateString(value);
            } catch (Exception e) {
                // If parsing fails, return the original value
                LOGGER.debug("Could not parse date value '{}' for attribute '{}': {}", value, attributeName, e.getMessage());
                return value;
            }
        }
        return value;
    }
    
    /**
     * Parse and format a date string to "06 Nov 20, 17:27:04" format
     */
    private String formatDateString(String dateStr) {
        if (dateStr == null || dateStr.trim().isEmpty()) {
            return dateStr;
        }
        
        try {
            // Try multiple date formats that might be in the CSV
            String[] possibleFormats = {
                "yyyy-MM-dd'T'HH:mm:ss.SSS",
                "yyyy-MM-dd'T'HH:mm:ss",
                "yyyy-MM-dd HH:mm:ss.SSS",
                "yyyy-MM-dd HH:mm:ss",
                "dd/MM/yyyy HH:mm:ss",
                "MM/dd/yyyy HH:mm:ss",
                "yyyy/MM/dd HH:mm:ss",
                "dd-MM-yyyy HH:mm:ss",
                "MM-dd-yyyy HH:mm:ss",
                "yyyy-MM-dd",
                "dd/MM/yyyy",
                "MM/dd/yyyy"
            };
            
            for (String format : possibleFormats) {
                try {
                    SimpleDateFormat parser = new SimpleDateFormat(format);
                    Date date = parser.parse(dateStr.trim());
                    
                    // Format to desired output format "06 Nov 20, 17:27:04"
                    SimpleDateFormat formatter = new SimpleDateFormat("dd MMM yy, HH:mm:ss");
                    return formatter.format(date);
                } catch (Exception ignored) {
                    // Try next format
                }
            }
            
            // If none of the formats work, return original
            return dateStr;
            
        } catch (Exception e) {
            LOGGER.debug("Error formatting date string '{}': {}", dateStr, e.getMessage());
            return dateStr;
        }
    }

    /**
     * Load case IDs from the selected log
     */
    private void loadCaseIdData() {
        try {
            if (caseIdValuesList != null) {
                caseIdValuesList.getItems().clear();
                
                // –ó–∞–≥—Ä—É–∂–∞–µ–º Case ID –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –ª–æ–≥–∞
                loadCaseIdsForLog();
            }
        } catch (Exception e) {
            LOGGER.error("Error loading case ID data", e);
        }
    }

    /**
     * Load Case IDs based on the selected log
     */
    private void loadCaseIdsForLog() {
        try {
            if (caseIdValuesList == null) {
                LOGGER.warn("‚ö†Ô∏è caseIdValuesList –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω");
                return;
            }

            LOGGER.info("üîÑ –ó–∞–≥—Ä—É–∂–∞–µ–º Case ID –¥–ª—è –ª–æ–≥–∞: {} (ID: {})", logName, logId);

            // –û—á–∏—â–∞–µ–º —Å–ø–∏—Å–æ–∫
            caseIdValuesList.getItems().clear();
            allCaseIdValues.clear();

            if (apmLog != null) {
                // –ü–æ–ª—É—á–∞–µ–º Case ID –∏–∑ APMLog
                Map<String, Integer> caseIdCounts = new HashMap<>();
                
                for (ATrace trace : apmLog.getTraces()) {
                    String caseId = trace.getCaseId();
                    if (caseId != null && !caseId.isEmpty()) {
                        int eventCount = trace.getActivityInstances().size();
                        caseIdCounts.put(caseId, eventCount);
                    }
                }
                
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—Å–µ Case ID –¥–ª—è –ø–∞–≥–∏–Ω–∞—Ü–∏–∏ –∏ —Å–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –∞–ª—Ñ–∞–≤–∏—Ç—É
                allCaseIdValues.addAll(caseIdCounts.keySet());
                allCaseIdValues.sort(String::compareToIgnoreCase); // –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –∞–ª—Ñ–∞–≤–∏—Ç—É –±–µ–∑ —É—á–µ—Ç–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞
                
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–µ—Ä–≤—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É
                currentCaseIdPage = 1;
                displayCaseIdPage(currentCaseIdPage);
                
                LOGGER.info("‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω—ã {} Case ID –¥–ª—è –ª–æ–≥–∞: {}", caseIdCounts.size(), logName);
                
            } else {
                LOGGER.warn("‚ö†Ô∏è APMLog –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º –∑–∞–≥–ª—É—à–µ—á–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ");
                // Fallback to sample data (already sorted)
                allCaseIdValues.addAll(Arrays.asList("Case_001", "Case_002", "Case_003", "Case_004", "Case_005"));
                currentCaseIdPage = 1;
                displayCaseIdPage(currentCaseIdPage);
            }

        } catch (Exception e) {
            LOGGER.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ Case ID –¥–ª—è –ª–æ–≥–∞: {}", logName, e);
        }
    }

    /**
     * Add case ID to the list
     */
    private void addCaseId(String caseId, int activityInstances) {
        if (caseIdValuesList != null) {
            Listitem item = new Listitem();
            item.appendChild(new Listcell(caseId));
            item.appendChild(new Listcell(String.valueOf(activityInstances)));
            
            caseIdValuesList.appendChild(item);
        }
    }


    /**
     * Load sample data when real log is not available
     */
    private void loadSampleData() {
        try {
            LOGGER.info("Loading sample data for testing");
            loadAttributeData();
            loadCaseIdData();
            updateStatistics();
        } catch (Exception e) {
            LOGGER.error("Error loading sample data", e);
        }
    }

    /**
     * Initialize navigation event handlers
     */
    private void initializeNavigation() {
        try {
            // Case filter navigation
            if (caseAttributeNav != null) {
                caseAttributeNav.addEventListener(Events.ON_CLICK, event -> showPanel("caseAttribute"));
            }
            if (caseVariantNav != null) {
                caseVariantNav.addEventListener(Events.ON_CLICK, event -> showPanel("caseVariant"));
            }
            if (caseIdNav != null) {
                caseIdNav.addEventListener(Events.ON_CLICK, event -> showPanel("caseId"));
            }
            if (timeframeNav != null) {
                timeframeNav.addEventListener(Events.ON_CLICK, event -> showPanel("timeframe"));
            }
            if (performanceNav != null) {
                performanceNav.addEventListener(Events.ON_CLICK, event -> showPanel("performance"));
            }
            if (pathNav != null) {
                pathNav.addEventListener(Events.ON_CLICK, event -> showPanel("path"));
            }
            if (reworkNav != null) {
                reworkNav.addEventListener(Events.ON_CLICK, event -> showPanel("rework"));
            }
            if (blocksNav != null) {
                blocksNav.addEventListener(Events.ON_CLICK, event -> showPanel("blocks"));
            }

            // Event filter navigation  
            if (eventAttributeNav != null) {
                eventAttributeNav.addEventListener(Events.ON_CLICK, event -> showPanel("eventAttribute"));
            }
            if (eventTimeframeNav != null) {
                eventTimeframeNav.addEventListener(Events.ON_CLICK, event -> showPanel("eventTimeframe"));
            }
            if (eventFrequencyNav != null) {
                eventFrequencyNav.addEventListener(Events.ON_CLICK, event -> showPanel("eventFrequency"));
            }
            if (eventPerformanceNav != null) {
                eventPerformanceNav.addEventListener(Events.ON_CLICK, event -> showPanel("eventPerformance"));
            }
            if (eventPathNav != null) {
                eventPathNav.addEventListener(Events.ON_CLICK, event -> showPanel("eventPath"));
            }
            if (eventBetweenNav != null) {
                eventBetweenNav.addEventListener(Events.ON_CLICK, event -> showPanel("eventBetween"));
            }

            LOGGER.info("Navigation initialized");
        } catch (Exception e) {
            LOGGER.error("Error initializing navigation", e);
        }
    }

    /**
     * Initialize control buttons
     */
    private void initializeControlButtons() {
        try {
            // Initialize apply filters button
            if (applyFiltersBtn != null) {
                applyFiltersBtn.addEventListener(Events.ON_CLICK, event -> applyFiltersAndRedirect());
            }
            
			// Bind Case Attribute panel's local Apply button
			if (applyFiltersBtnCaseAttribute != null) {
				applyFiltersBtnCaseAttribute.addEventListener(Events.ON_CLICK, event -> {
					currentFilter = "caseAttribute";
					applyFiltersAndRedirect();
				});
			}

            // Bind Case ID panel's local Apply button
            if (applyFiltersBtnCaseId != null) {
                applyFiltersBtnCaseId.addEventListener(Events.ON_CLICK, event -> {
                    currentFilter = "caseId";
                    applyFiltersAndRedirect();
                });
            }

            // Initialize cancel button
            if (cancelBtn != null) {
                cancelBtn.addEventListener(Events.ON_CLICK, event -> closeWindow());
            }
            
			LOGGER.info("Control buttons initialized");
        } catch (Exception e) {
            LOGGER.error("Error initializing control buttons", e);
        }
    }
    
    /**
     * Initialize timeframe filter components
     */
    private void initializeTimeframeFilter() {
        try {
            // Set default containment type to "start in"
            setContainmentIcon("start");
            
            // Initialize date inputs with current date
            if (fromDate != null) {
                fromDate.setDisabled(false);
                fromDate.setValue(new Date());
            }
            if (toDate != null) {
                toDate.setDisabled(true);
                if (apmLog != null) {
                    toDate.setValue(new Date(apmLog.getEndTime()));
                } else {
                    toDate.setValue(new Date());
                }
            }
            
            // Initialize time chart
            initializeTimeChart();
            
            LOGGER.info("Timeframe filter initialized");
        } catch (Exception e) {
            LOGGER.error("Error initializing timeframe filter", e);
        }
    }

    /**
     * Show specific filter panel and update navigation
     */
    private void showPanel(String panelName) {
        try {
            // Hide all panels
            hideAllPanels();
            
            // Reset all navigation button styles
            resetNavigation();
            
            // Show selected panel and highlight navigation
            switch (panelName) {
                case "caseAttribute":
                    if (caseAttributePanel != null) caseAttributePanel.setVisible(true);
                    if (caseAttributeNav != null) caseAttributeNav.setSclass("filter-nav-item selected");
                    break;
                case "caseId":
                    if (caseIdPanel != null) caseIdPanel.setVisible(true);
                    if (caseIdNav != null) caseIdNav.setSclass("filter-nav-item selected");
                    break;
                case "caseVariant":
                    if (caseVariantPanel != null) caseVariantPanel.setVisible(true);
                    if (caseVariantNav != null) caseVariantNav.setSclass("filter-nav-item selected");
                    break;
                case "timeframe":
                    LOGGER.info("Showing timeframe panel...");
                    if (timeframePanel != null) {
                        timeframePanel.setVisible(true);
                        LOGGER.info("Timeframe panel visibility set to true");
                    } else {
                        LOGGER.error("Timeframe panel is null!");
                    }
                    if (timeframeNav != null) timeframeNav.setSclass("filter-nav-item selected");
                    // Initialize time chart when timeframe panel is shown
                    LOGGER.info("Timeframe panel shown, initializing time chart...");
                    // Use a timer to ensure the panel is fully rendered before initializing
                    java.util.Timer timer = new java.util.Timer();
                    timer.schedule(new TimerTask() {
                        @Override
                        public void run() {
                            try {
                                LOGGER.info("Timer triggered, initializing time chart...");
                                initializeTimeChart();
                            } catch (Exception e) {
                                LOGGER.error("Error initializing time chart from timer", e);
                            }
                        }
                    }, 200);
                    break;
                case "performance":
                    if (performancePanel != null) performancePanel.setVisible(true);
                    if (performanceNav != null) performanceNav.setSclass("filter-nav-item selected");
            initializePerformanceFilter();
                    break;
                case "path":
                    if (pathPanel != null) pathPanel.setVisible(true);
                    if (pathNav != null) pathNav.setSclass("filter-nav-item selected");
                    break;
                case "rework":
                    if (reworkPanel != null) reworkPanel.setVisible(true);
                    if (reworkNav != null) reworkNav.setSclass("filter-nav-item selected");
                    break;
                case "blocks":
                    if (blocksPanel != null) blocksPanel.setVisible(true);
                    if (blocksNav != null) blocksNav.setSclass("filter-nav-item selected");
                    break;
                // Event filters would be handled similarly
                default:
                    LOGGER.warn("Unknown panel: " + panelName);
                    // Default to case attribute
                    if (caseAttributePanel != null) caseAttributePanel.setVisible(true);
                    if (caseAttributeNav != null) caseAttributeNav.setSclass("filter-nav-item selected");
                    break;
            }
            
            this.currentFilter = panelName;
            LOGGER.info("Switched to {} filter panel", panelName);
            
        } catch (Exception e) {
            LOGGER.error("Error showing panel: " + panelName, e);
        }
    }

    /**
     * Hide all filter panels
     */
    private void hideAllPanels() {
        if (caseAttributePanel != null) caseAttributePanel.setVisible(false);
        if (caseIdPanel != null) caseIdPanel.setVisible(false);
        if (caseVariantPanel != null) caseVariantPanel.setVisible(false);
        if (timeframePanel != null) timeframePanel.setVisible(false);
        if (performancePanel != null) performancePanel.setVisible(false);
        if (pathPanel != null) pathPanel.setVisible(false);
        if (reworkPanel != null) reworkPanel.setVisible(false);
        if (blocksPanel != null) blocksPanel.setVisible(false);
    }

    /**
     * Reset all navigation button styles
     */
    private void resetNavigation() {
        if (caseAttributeNav != null) caseAttributeNav.setSclass("filter-nav-item");
        if (caseVariantNav != null) caseVariantNav.setSclass("filter-nav-item");
        if (caseIdNav != null) caseIdNav.setSclass("filter-nav-item");
        if (timeframeNav != null) timeframeNav.setSclass("filter-nav-item");
        if (performanceNav != null) performanceNav.setSclass("filter-nav-item");
        if (pathNav != null) pathNav.setSclass("filter-nav-item");
        if (reworkNav != null) reworkNav.setSclass("filter-nav-item");
        if (blocksNav != null) blocksNav.setSclass("filter-nav-item");
        if (eventAttributeNav != null) eventAttributeNav.setSclass("filter-nav-item");
        if (eventTimeframeNav != null) eventTimeframeNav.setSclass("filter-nav-item");
        if (eventFrequencyNav != null) eventFrequencyNav.setSclass("filter-nav-item");
        if (eventPerformanceNav != null) eventPerformanceNav.setSclass("filter-nav-item");
        if (eventPathNav != null) eventPathNav.setSclass("filter-nav-item");
        if (eventBetweenNav != null) eventBetweenNav.setSclass("filter-nav-item");
    }

    /**
     * Apply filters and redirect to Process Discoverer
     */
    private void applyFiltersAndRedirect() {
        try {
            LOGGER.info("üéØ –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Ñ–∏–ª—å—Ç—Ä–æ–≤ –∫ –ª–æ–≥—É: {} (ID: {})", logName, logId);
            
            // Get current filter settings and selected values (do not apply yet)
            String filterDescription = getCurrentFilterDescription();
            List<String> selectedValues = getSelectedFilterValues();

            if (selectedValues.isEmpty()) {
                Messagebox.show("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏", 
                              "–§–∏–ª—å—Ç—Ä—ã –Ω–µ –≤—ã–±—Ä–∞–Ω—ã", Messagebox.OK, Messagebox.EXCLAMATION);
                return;
            }
            // Create rules now, but DO NOT APPLY. Accumulate to pass into criteria window.
            List<LogFilterRule> newRules = createFilterRules(selectedValues);
            if (newRules == null || newRules.isEmpty()) {
                Messagebox.show("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –ø—Ä–∞–≤–∏–ª–∞ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏", "–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ", Messagebox.OK, Messagebox.EXCLAMATION);
                return;
            }

            // Merge with any existing criteria passed in (if this is the second+ filter)
            if (currentCriteria == null) currentCriteria = new ArrayList<>();
            List<LogFilterRule> combinedRules = new ArrayList<>(currentCriteria);
            combinedRules.addAll(newRules);

            // Merge descriptions using already accumulated ones if available
            List<String> combinedDescriptions = new java.util.ArrayList<>();
            if (criteriaDescriptionsFromArgs != null && !criteriaDescriptionsFromArgs.isEmpty()) {
                combinedDescriptions.addAll(criteriaDescriptionsFromArgs);
            } else {
                try {
                    Map<?, ?> inArgs = org.zkoss.zk.ui.Executions.getCurrent().getArg();
                    Object prevDescs = inArgs != null ? inArgs.get("criteriaDescriptions") : null;
                    if (prevDescs instanceof java.util.List) {
                        //noinspection unchecked
                        combinedDescriptions.addAll((java.util.List<String>) prevDescs);
                    }
                } catch (Exception ignore) {}
            }
            String desc = filterDescription != null ? filterDescription : "Filter";
            combinedDescriptions.add(desc);

            // Prepare args for criteria window
            java.util.Map<String,Object> args = new java.util.HashMap<>();
            args.put("criteriaDescriptions", combinedDescriptions);
            args.put("criteriaRules", combinedRules);
            // pass-through original context so "+" can reopen filter with proper log and client
            if (this.portalContext != null) args.put("portalContext", this.portalContext);
            if (this.selectedLog != null) args.put("selectedLog", this.selectedLog);
            if (this.logName != null) args.put("logName", this.logName);
            if (this.logId != null) args.put("logId", this.logId);
            if (this.apmLog != null) args.put("apmLog", this.apmLog);
            if (this.logFilterClient != null) args.put("logFilterClient", this.logFilterClient);

            // Close the current filter window first
            LOGGER.info("üîß Closing current filter window before opening criteria window...");
            closeWindow();
            
            // Additional cleanup to ensure no lingering windows
            try {
                org.zkoss.zk.ui.Desktop desktop = org.zkoss.zk.ui.Executions.getCurrent().getDesktop();
                if (desktop != null) {
                    for (org.zkoss.zk.ui.Page page : desktop.getPages()) {
                        org.zkoss.zk.ui.Component old = page.getFellowIfAny("logFilterWindow");
                        if (old != null) {
                            LOGGER.info("üîß Found lingering logFilterWindow, detaching...");
                            try { old.detach(); } catch (Exception ignored) {}
                        }
                    }
                }
            } catch (Exception ignored) {}
            
            LOGGER.info("üîß Filter window cleanup completed, opening criteria window...");
            // Always load via classloader to avoid context-relative path issues
            org.zkoss.zul.Window w = null;
            if (portalContext != null && portalContext.getUI() != null) {
                w = (org.zkoss.zul.Window) portalContext.getUI()
                        .createComponent(getClass().getClassLoader(), "filterCriteria.zul", null, args);
            } else {
                w = (org.zkoss.zul.Window) org.zkoss.zk.ui.Executions.getCurrent()
                        .createComponentsDirectly(
                                new java.io.InputStreamReader(
                                        getClass().getClassLoader().getResourceAsStream("filterCriteria.zul"),
                                        java.nio.charset.StandardCharsets.UTF_8),
                                "zul", null, args);
            }
            if (w != null) {
                w.doModal();
            }
            LOGGER.info("üéØ –ö—Ä–∏—Ç–µ—Ä–∏–π –¥–æ–±–∞–≤–ª–µ–Ω (–±–µ–∑ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è): {} –∑–Ω–∞—á–µ–Ω–∏–π –¥–ª—è {}", selectedValues.size(), filterDescription);
            
        } catch (Exception e) {
            LOGGER.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–∏ —Ñ–∏–ª—å—Ç—Ä–æ–≤ –∫ {} (ID: {})", logName, logId, e);
            Messagebox.show("–û—à–∏–±–∫–∞ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è —Ñ–∏–ª—å—Ç—Ä–æ–≤ –∫ " + (logName != null ? logName : "–ª–æ–≥—É") + ": " + e.getMessage(), 
                          "–û—à–∏–±–∫–∞", Messagebox.OK, Messagebox.ERROR);
        }
    }

    /**
     * Clear all filters and restore original log
     */
    public void clearAllFilters() {
        try {
            LOGGER.info("üßπ –°–±—Ä–æ—Å –≤—Å–µ—Ö —Ñ–∏–ª—å—Ç—Ä–æ–≤ –¥–ª—è –ª–æ–≥–∞: {} (ID: {})", logName, logId);
            
            // –ü—Ä–æ—Å—Ç–æ –∑–∞–∫—Ä—ã–≤–∞–µ–º –æ–∫–Ω–æ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
            // Process Discoverer —Å–∞–º –æ–±—Ä–∞–±–æ—Ç–∞–µ—Ç —Å–±—Ä–æ—Å —Ñ–∏–ª—å—Ç—Ä–æ–≤
            closeWindow();
            
            LOGGER.info("‚úÖ –û–∫–Ω–æ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –∑–∞–∫—Ä—ã—Ç–æ");
            
        } catch (Exception e) {
            LOGGER.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–±—Ä–æ—Å–µ —Ñ–∏–ª—å—Ç—Ä–æ–≤", e);
            Messagebox.show("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–±—Ä–æ—Å–µ —Ñ–∏–ª—å—Ç—Ä–æ–≤: " + e.getMessage(), 
                          "–û—à–∏–±–∫–∞", Messagebox.OK, Messagebox.ERROR);
        }
    }
    
    /**
     * Reload Process Discoverer without filters
     */
    private void reloadProcessDiscovererWithoutFilters() {
        try {
            LOGGER.info("üîÑ –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∞ Process Discoverer –±–µ–∑ —Ñ–∏–ª—å—Ç—Ä–æ–≤");
            
            // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–π –∫–æ–Ω—Ç–µ–∫—Å—Ç
            org.zkoss.zk.ui.Execution current = org.zkoss.zk.ui.Executions.getCurrent();
            
            // –°–æ–∑–¥–∞–µ–º –∞—Ä–≥—É–º–µ–Ω—Ç—ã –¥–ª—è –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∏
            Map<String, Object> args = new HashMap<>();
            args.put("logId", logId);
            args.put("logName", logName);
            args.put("clearFilters", true);
            
            // –ü–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞ Process Discoverer
            current.sendRedirect("/processdiscoverer");
            
            LOGGER.info("‚úÖ Process Discoverer –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∂–µ–Ω –±–µ–∑ —Ñ–∏–ª—å—Ç—Ä–æ–≤");
            
        } catch (Exception e) {
            LOGGER.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–µ Process Discoverer", e);
        }
    }

    /**
     * Get selected filter values from current panel
     */
    private List<String> getSelectedFilterValues() {
        List<String> selectedValues = new ArrayList<>();
        
        try {
            switch (currentFilter) {
                case "caseAttribute":
                    if (attributeValuesList != null) {
                        for (Listitem item : attributeValuesList.getSelectedItems()) {
                            if (item.getFirstChild() instanceof Listcell) {
                                Listcell cell = (Listcell) item.getFirstChild();
                                if (cell.getLabel() != null) {
                                    selectedValues.add(cell.getLabel());
                                }
                            }
                        }
                    }
                    break;
                    
                case "caseId":
                    if (caseIdValuesList != null) {
                        for (Listitem item : caseIdValuesList.getSelectedItems()) {
                            if (item.getFirstChild() instanceof Listcell) {
                                Listcell cell = (Listcell) item.getFirstChild();
                                if (cell.getLabel() != null) {
                                    selectedValues.add(cell.getLabel());
                                }
                            }
                        }
                    }
                    break;
                    
                case "timeframe":
                    long ft = getFromTime();
                    long tt = getToTime();
                    String ct = getSelectedContainmentType();
                    selectedValues.add("timeframe:" + ct + ":" + ft + ":" + tt);
                    break;
                
                case "performance":
                    // Encode selection to bypass empty-check and for logging
                    String measure = performanceMeasure != null && performanceMeasure.getSelectedItem() != null ? performanceMeasure.getSelectedItem().getLabel() : "Case duration";
                    if ("Case length".equals(measure)) {
                        Integer from = perfLenFrom != null ? perfLenFrom.getValue() : null;
                        Integer to = perfLenTo != null ? perfLenTo.getValue() : null;
                        if ((from != null && from > 0) || (to != null && to > 0)) {
                            selectedValues.add("performance:length:" + (from != null ? from : "") + ":" + (to != null ? to : ""));
                        }
                    } else {
                        long gteMsSel = toMillis(perfGteValue, perfGteUnit);
                        long lteMsSel = toMillis(perfLteValue, perfLteUnit);
                        if (gteMsSel > 0 || lteMsSel > 0) {
                            selectedValues.add("performance:" + measure + ":" + gteMsSel + ":" + lteMsSel);
                        }
                    }
                    break;
                
                default:
                    LOGGER.warn("–ü–æ–ª—É—á–µ–Ω–∏–µ –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π –¥–ª—è {} –ø–æ–∫–∞ –Ω–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ", currentFilter);
                    break;
            }
        } catch (Exception e) {
            LOGGER.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π", e);
        }
        
        return selectedValues;
    }

    /**
     * Open filtered log in Process Discoverer
     */
    private void openInProcessDiscoverer(List<String> selectedValues, String filterDescription) {
        try {
            LOGGER.info("üöÄ –û—Ç–∫—Ä—ã—Ç–∏–µ –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –ª–æ–≥–∞ –≤ Process Discoverer");
            LOGGER.info("üìã –§–∏–ª—å—Ç—Ä: {}", filterDescription);
            LOGGER.info("üìä –ó–Ω–∞—á–µ–Ω–∏—è: {}", selectedValues);
            
            if (logId == null || logId <= 0 || portalContext == null) {
                LOGGER.error("‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è Process Discoverer: logId={}, portalContext={}", logId, portalContext);
                Messagebox.show("–û—à–∏–±–∫–∞: –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è Process Discoverer", "–û—à–∏–±–∫–∞", Messagebox.OK, Messagebox.ERROR);
                return;
            }
            
            Set<LogSummaryType> selectedLogs = getSelectedLogsFromContext();
            if (selectedLogs.isEmpty()) {
                LOGGER.error("‚ùå –ù–µ –≤—ã–±—Ä–∞–Ω –ª–æ–≥ –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è –≤ Process Discoverer");
                Messagebox.show("–û—à–∏–±–∫–∞: –Ω–µ –≤—ã–±—Ä–∞–Ω –ª–æ–≥", "–û—à–∏–±–∫–∞", Messagebox.OK, Messagebox.ERROR);
                return;
            }
            
            LogSummaryType selectedLog = selectedLogs.iterator().next();
            
            // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π PDFrequencyPlugin –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è Process Discoverer
            if (processDiscovererPlugin != null) {
                LOGGER.info("‚úÖ –ò—Å–ø–æ–ª—å–∑—É–µ–º PDFrequencyPlugin –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è Process Discoverer");
                
                try {
                    // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ä–µ—Ñ–ª–µ–∫—Å–∏—é –¥–ª—è –≤—ã–∑–æ–≤–∞ –º–µ—Ç–æ–¥–∞ openWithFilters
                    java.lang.reflect.Method openWithFiltersMethod = 
                        processDiscovererPlugin.getClass().getMethod("openWithFilters", 
                            org.apromore.plugin.portal.PortalContext.class, 
                            java.util.List.class);
                    
                    // –°–æ–∑–¥–∞–µ–º –ø—Ä–æ—Å—Ç—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π
                    List<Object> logFilters = new ArrayList<>();
                    
                    // –í—ã–∑—ã–≤–∞–µ–º –º–µ—Ç–æ–¥ —á–µ—Ä–µ–∑ —Ä–µ—Ñ–ª–µ–∫—Å–∏—é
                    openWithFiltersMethod.invoke(processDiscovererPlugin, portalContext, logFilters);
                    
                    LOGGER.info("‚úÖ Process Discoverer –æ—Ç–∫—Ä—ã—Ç —á–µ—Ä–µ–∑ PDFrequencyPlugin:");
                    LOGGER.info("   - –õ–æ–≥: {} (ID: {})", selectedLog.getName(), selectedLog.getId());
                    LOGGER.info("   - –¢–∏–ø —Ñ–∏–ª—å—Ç—Ä–∞: {}", currentFilter);
                    LOGGER.info("   - –í—ã–±—Ä–∞–Ω–æ –∑–Ω–∞—á–µ–Ω–∏–π: {}", selectedValues.size());
                    
                    Messagebox.show("–õ–æ–≥ —Å –ø—Ä–∏–º–µ–Ω–µ–Ω–Ω—ã–º–∏ —Ñ–∏–ª—å—Ç—Ä–∞–º–∏ –æ—Ç–∫—Ä—ã—Ç –≤ Process Discoverer", 
                                  "–£—Å–ø–µ—Ö", Messagebox.OK, Messagebox.INFORMATION);
                    
                } catch (Exception e) {
                    LOGGER.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–∑–æ–≤–µ PDFrequencyPlugin —á–µ—Ä–µ–∑ —Ä–µ—Ñ–ª–µ–∫—Å–∏—é", e);
                    // Fallback –∫ –ø—Ä—è–º–æ–º—É URL
                    throw e;
                }
                
            } else {
                LOGGER.warn("‚ö†Ô∏è PDFrequencyPlugin –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä—è–º–æ–π URL");
                
                // Fallback: –ø—Ä—è–º–æ–π URL
                String pdUrl = String.format("processdiscoverer/zul/processDiscoverer.zul?REFER_ID=%s", 
                                            Executions.getCurrent().getDesktop().getId());
                
                String jsCode = String.format("window.open('%s', '_blank', 'width=1200,height=800,scrollbars=yes,resizable=yes');", pdUrl);
                Clients.evalJavaScript(jsCode);
                
                LOGGER.info("‚úÖ Process Discoverer –æ—Ç–∫—Ä—ã—Ç —á–µ—Ä–µ–∑ –ø—Ä—è–º–æ–π URL: {}", pdUrl);
                Messagebox.show("–õ–æ–≥ —Å –ø—Ä–∏–º–µ–Ω–µ–Ω–Ω—ã–º–∏ —Ñ–∏–ª—å—Ç—Ä–∞–º–∏ –æ—Ç–∫—Ä—ã—Ç –≤ Process Discoverer", 
                              "–£—Å–ø–µ—Ö", Messagebox.OK, Messagebox.INFORMATION);
            }
            
        } catch (Exception e) {
            LOGGER.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏ –≤ Process Discoverer", e);
            Messagebox.show("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏ Process Discoverer: " + e.getMessage(), 
                          "–û—à–∏–±–∫–∞", Messagebox.OK, Messagebox.ERROR);
        }
    }

    /**
     * Get description of current filter settings
     */
    private String getCurrentFilterDescription() {
        try {
            switch (currentFilter) {
                case "caseAttribute":
                    String condition = caseAttributeCondition != null && caseAttributeCondition.getSelectedItem() != null ? 
                        caseAttributeCondition.getSelectedItem().getValue() : "retain";
                    String attribute = primaryAttributeCombo != null ? primaryAttributeCombo.getValue() : "Activity";
                    
                    // Count selected values
                    int selectedCount = 0;
                    if (attributeValuesList != null) {
                        selectedCount = attributeValuesList.getSelectedItems().size();
                    }
                    
                    return String.format("Case Attribute Filter: %s cases where '%s' matches %d selected values", 
                        condition.equals("retain") ? "Retain" : "Remove", attribute, selectedCount);
                        
                case "caseId":
                    String idCondition = caseIdCondition != null && caseIdCondition.getSelectedItem() != null ? 
                        caseIdCondition.getSelectedItem().getValue() : "retain";
                    
                    int selectedIds = 0;
                    if (caseIdValuesList != null) {
                        selectedIds = caseIdValuesList.getSelectedItems().size();
                    }
                    
                    return String.format("Case ID Filter: %s %d selected case IDs", 
                        idCondition.equals("retain") ? "Retain" : "Remove", selectedIds);
                        
                default:
                    return currentFilter + " filter (configuration pending)";
            }
        } catch (Exception e) {
            LOGGER.error("Error getting filter description", e);
            return "Filter applied";
        }
    }

    /**
     * Get selected logs from portal context
     */
    private Set<LogSummaryType> getSelectedLogsFromContext() {
        Set<LogSummaryType> selectedLogs = new HashSet<>();
        
        try {
            if (portalContext != null) {
                Map<SummaryType, List<VersionSummaryType>> elements = 
                    portalContext.getSelection().getSelectedProcessModelVersions();
                    
                for (Map.Entry<SummaryType, List<VersionSummaryType>> entry : elements.entrySet()) {
                    if (entry.getKey() instanceof LogSummaryType) {
                        selectedLogs.add((LogSummaryType) entry.getKey());
                    }
                }
            }
        } catch (Exception e) {
            LOGGER.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –ª–æ–≥–æ–≤", e);
        }
        
        return selectedLogs;
    }
    
    /**
     * Prepare Process Discoverer session with proper initialization
     */
    private String prepareProcessDiscovererSession(LogSummaryType selectedLog, List<String> selectedValues, String filterDescription) {
        try {
            LOGGER.info("üîÑ –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ —Å–µ—Å—Å–∏–∏ Process Discoverer –¥–ª—è –ª–æ–≥–∞: {}", selectedLog.getName());
            
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ñ–∏–ª—å—Ç—Ä–∞—Ö –≤ —Å–µ—Å—Å–∏—é –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ Process Discoverer
            Map<String, Object> filterData = new HashMap<>();
            filterData.put("filterType", currentFilter);
            filterData.put("filterDescription", filterDescription);
            filterData.put("selectedValues", selectedValues);
            filterData.put("logId", selectedLog.getId());
            filterData.put("logName", selectedLog.getName());
            
            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–π ID —Å–µ—Å—Å–∏–∏
            String sessionId = "filter_" + selectedLog.getId() + "_" + System.currentTimeMillis();
            Sessions.getCurrent().setAttribute(sessionId, filterData);
            
            LOGGER.info("‚úÖ –î–∞–Ω–Ω—ã–µ —Ñ–∏–ª—å—Ç—Ä–æ–≤ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ —Å–µ—Å—Å–∏–∏: {}", sessionId);
            return sessionId;
            
        } catch (Exception e) {
            LOGGER.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Å–µ—Å—Å–∏–∏ Process Discoverer", e);
            return null;
        }
    }
    
    /**
     * Apply filters directly to Process Discoverer
     */
    private void applyFiltersToProcessDiscoverer(List<String> selectedValues, String filterDescription) {
        try {
            LOGGER.info("üéØ –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Ñ–∏–ª—å—Ç—Ä–æ–≤ –∫ Process Discoverer");
            LOGGER.info("üìã –§–∏–ª—å—Ç—Ä: {}", filterDescription);
            LOGGER.info("üìä –ó–Ω–∞—á–µ–Ω–∏—è: {}", selectedValues);
            
            if (logFilterClient == null) {
                LOGGER.error("‚ùå LogFilterClient –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω");
                Messagebox.show("–û—à–∏–±–∫–∞: LogFilterClient –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω", "–û—à–∏–±–∫–∞", Messagebox.OK, Messagebox.ERROR);
                return;
            }
            
            // –°–æ–∑–¥–∞–µ–º –ø—Ä–∞–≤–∏–ª–∞ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π
            LOGGER.info("üîß –°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–∞–≤–∏–ª —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏...");
            List<LogFilterRule> filterRules = createFilterRules(selectedValues);
            LOGGER.info("üîß –°–æ–∑–¥–∞–Ω–æ –ø—Ä–∞–≤–∏–ª: {}", filterRules.size());
            
            if (filterRules.isEmpty()) {
                LOGGER.warn("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –ø—Ä–∞–≤–∏–ª–∞ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏");
                Messagebox.show("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –ø—Ä–∞–≤–∏–ª–∞ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏", "–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ", Messagebox.OK, Messagebox.EXCLAMATION);
                return;
            }
            
            // –°–æ–∑–¥–∞–µ–º LogFilterResponse —Å –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–Ω—ã–º –ª–æ–≥–æ–º
            LOGGER.info("üîß –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Ñ–∏–ª—å—Ç—Ä–æ–≤ –∫ –ª–æ–≥—É...");
            APMLog filteredLog = applyFiltersToLog(filterRules);
            LOGGER.info("üîß –†–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è —Ñ–∏–ª—å—Ç—Ä–æ–≤: {}", filteredLog != null ? "—É—Å–ø–µ—à–Ω–æ" : "–Ω–µ—É–¥–∞—á–Ω–æ");
            
            if (filteredLog == null) {
                LOGGER.error("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–∏–º–µ–Ω–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä—ã –∫ –ª–æ–≥—É");
                Messagebox.show("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–∏–º–µ–Ω–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä—ã –∫ –ª–æ–≥—É", "–û—à–∏–±–∫–∞", Messagebox.OK, Messagebox.ERROR);
                return;
            }
            
            // –°–æ–∑–¥–∞–µ–º PLog –∏–∑ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–≥–æ APMLog –∏ –ø—Ä–∏–º–µ–Ω—è–µ–º —Ñ–∏–ª—å—Ç—Ä—ã
            LOGGER.info("üîß –°–æ–∑–¥–∞–Ω–∏–µ PLog –∏–∑ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–≥–æ APMLog...");
            LOGGER.info("üîß –û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π APMLog —Å–æ–¥–µ—Ä–∂–∏—Ç {} —Ç—Ä–∞—Å—Å", apmLog.getTraces().size());
            
            PLog filteredPLog = new PLog(apmLog);
            LOGGER.info("üîß PLog —Å–æ–∑–¥–∞–Ω —É—Å–ø–µ—à–Ω–æ –∏–∑ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–≥–æ –ª–æ–≥–∞");
            LOGGER.info("üîß PLog —Å–æ–¥–µ—Ä–∂–∏—Ç {} —Ç—Ä–∞—Å—Å", filteredPLog.getPTraces().size());
            
            // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ñ–∏–ª—å—Ç—Ä—ã –∫ PLog
            LOGGER.info("üîß –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Ñ–∏–ª—å—Ç—Ä–æ–≤ –∫ PLog...");
            APMLogFilter pLogFilter = new APMLogFilter(apmLog);
            pLogFilter.filter(filterRules);
            filteredPLog = pLogFilter.getPLog();
            
            LOGGER.info("üîß PLog –ø–æ—Å–ª–µ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ —Å–æ–¥–µ—Ä–∂–∏—Ç {} —Ç—Ä–∞—Å—Å", filteredPLog.getPTraces().size());
            
            if (filteredPLog.getPTraces().isEmpty()) {
                LOGGER.error("PLog –ø—É—Å—Ç –ø–æ—Å–ª–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è —Ñ–∏–ª—å—Ç—Ä–æ–≤");
                Messagebox.show("–û—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–Ω—ã–π –ª–æ–≥ –ø—É—Å—Ç. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥–∏–µ –∫—Ä–∏—Ç–µ—Ä–∏–∏ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏.", 
                              "–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ", Messagebox.OK, Messagebox.EXCLAMATION);
                return;
            }
            
            // –°–æ–∑–¥–∞–µ–º LogFilterResponse
            LOGGER.info("–°–æ–∑–¥–∞–Ω–∏–µ LogFilterResponse...");
            LOGGER.info("Log ID: {}", logId);
            LOGGER.info("Log Name: {}", logName);
            LOGGER.info("Filtered PLog traces: {}", filteredPLog.getPTraces().size());
            LOGGER.info("Filter rules count: {}", filterRules.size());
            
            LogFilterResponse response = new LogFilterResponse(
                logId,
                logName,
                apmLog,  //–æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –ª–æ–≥
                filteredPLog,  // –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–Ω—ã–π –ª–æ–≥
                filterRules,  //–ø—Ä–∏–º–µ–Ω–µ–Ω–Ω—ã–µ –ø—Ä–∞–≤–∏–ª–∞
                new HashMap<>()  //–¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
            );
            
            LOGGER.info("LogFilterResponse —Å–æ–∑–¥–∞–Ω —É—Å–ø–µ—à–Ω–æ");
            
            //–æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –æ—Ç–≤–µ—Ç —á–µ—Ä–µ–∑ LogFilterClient
            logFilterClient.processResponse(response);
            
            LOGGER.info("–§–∏–ª—å—Ç—Ä—ã —É—Å–ø–µ—à–Ω–æ –ø—Ä–∏–º–µ–Ω–µ–Ω—ã –∫ Process Discoverer:");
            LOGGER.info("   - –õ–æ–≥: {} (ID: {})", logName, logId);
            LOGGER.info("   - –¢–∏–ø —Ñ–∏–ª—å—Ç—Ä–∞: {}", currentFilter);
            LOGGER.info("   - –í—ã–±—Ä–∞–Ω–æ –∑–Ω–∞—á–µ–Ω–∏–π: {}", selectedValues.size());
            LOGGER.info("   - –°–æ–∑–¥–∞–Ω–æ –ø—Ä–∞–≤–∏–ª: {}", filterRules.size());
            LOGGER.info("   - –¢—Ä–∞—Å—Å –≤ –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–Ω–æ–º –ª–æ–≥–µ: {}", filteredLog.getTraces().size());
            
            Messagebox.show("–§–∏–ª—å—Ç—Ä—ã —É—Å–ø–µ—à–Ω–æ –ø—Ä–∏–º–µ–Ω–µ–Ω—ã –∫ Process Discoverer", 
                          "–£—Å–ø–µ—Ö", Messagebox.OK, Messagebox.INFORMATION);
            
            //–∑–∞–∫—Ä—ã–≤–∞–µ—Ç –æ–∫–Ω–æ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
            closeWindow();
            
        } catch (Exception e) {
            LOGGER.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–∏ —Ñ–∏–ª—å—Ç—Ä–æ–≤ –∫ Process Discoverer", e);
            LOGGER.error("–ü–æ–ª–Ω—ã–π —Å—Ç–µ–∫ –æ—à–∏–±–∫–∏:", e);
            Messagebox.show("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–∏ —Ñ–∏–ª—å—Ç—Ä–æ–≤: " + e.getMessage(), 
                          "–û—à–∏–±–∫–∞", Messagebox.OK, Messagebox.ERROR);
        }
    }
    
    /**
     * Create filter rules based on selected values and current filter type
     */
    private List<LogFilterRule> createFilterRules(List<String> selectedValues) {
        List<LogFilterRule> rules = new ArrayList<>();
        
        try {
            LOGGER.info("–°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–∞–≤–∏–ª —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –¥–ª—è —Ç–∏–ø–∞: {}", currentFilter);
            LOGGER.info("–í—ã–±—Ä–∞–Ω–æ –∑–Ω–∞—á–µ–Ω–∏–π: {}", selectedValues.size());
            LOGGER.info("–ó–Ω–∞—á–µ–Ω–∏—è: {}", selectedValues);
            
            switch (currentFilter) {
                case "caseAttribute":
                    rules = createAttributeFilterRules(selectedValues);
                    break;
                case "caseId":
                    rules = createCaseIdFilterRules(selectedValues);
                    break;
                case "timeframe":
                    rules = createTimeframeFilterRules();
                    break;
                case "performance":
                    rules = createPerformanceFilterRules();
                    break;
                default:
                    LOGGER.warn("–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ç–∏–ø —Ñ–∏–ª—å—Ç—Ä–∞: {}", currentFilter);
                    break;
            }
            
            LOGGER.info("–°–æ–∑–¥–∞–Ω–æ {} –ø—Ä–∞–≤–∏–ª —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏", rules.size());
            
        } catch (Exception e) {
            LOGGER.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –ø—Ä–∞–≤–∏–ª —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏", e);
            LOGGER.error("–ü–æ–ª–Ω—ã–π —Å—Ç–µ–∫ –æ—à–∏–±–∫–∏:", e);
            LOGGER.error("–¢–∏–ø –æ—à–∏–±–∫–∏: {}", e.getClass().getSimpleName());
            LOGGER.error("–°–æ–æ–±—â–µ–Ω–∏–µ –æ—à–∏–±–∫–∏: {}", e.getMessage());
        }
        
        return rules;
    }
    
    /**
     * Create filter rules for Attribute filtering (both Case and Event attributes)
     */
    private List<LogFilterRule> createAttributeFilterRules(List<String> selectedValues) {
        List<LogFilterRule> rules = new ArrayList<>();
        
        try {
            // Get the selected attribute type (Event vs Case)
            String selectedAttributeType = "event"; // default to event
            if (primaryAttributeType != null && primaryAttributeType.getSelectedItem() != null) {
                selectedAttributeType = primaryAttributeType.getSelectedItem().getValue();
                LOGGER.info("üîß Radio button selection: primaryAttributeType={}, selectedItem={}, value={}", 
                           primaryAttributeType, primaryAttributeType.getSelectedItem(), selectedAttributeType);
            } else {
                LOGGER.warn("‚ö†Ô∏è primaryAttributeType is null or has no selected item");
                if (primaryAttributeType == null) {
                    LOGGER.warn("‚ö†Ô∏è primaryAttributeType is null");
                } else {
                    LOGGER.warn("‚ö†Ô∏è primaryAttributeType.getSelectedItem() is null");
                }
            }
            
                           // Get the selected attribute
               String selectedAttribute = "concept:name"; // default
               if (primaryAttributeCombo != null && primaryAttributeCombo.getSelectedItem() != null) {
                   Comboitem selectedItem = primaryAttributeCombo.getSelectedItem();
                   // Try to get value first, then fallback to label if value is null
                   if (selectedItem.getValue() != null) {
                       selectedAttribute = String.valueOf(selectedItem.getValue());
                   } else if (selectedItem.getLabel() != null) {
                       selectedAttribute = selectedItem.getLabel();
                   }
                   LOGGER.info("üîß –í—ã–±—Ä–∞–Ω–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç: value='{}', label='{}', –∏—Å–ø–æ–ª—å–∑—É–µ–º: '{}'", 
                              selectedItem.getValue(), selectedItem.getLabel(), selectedAttribute);
               }
               
               // Add debugging to show what we're creating
               LOGGER.info("üîß –°–æ–∑–¥–∞–Ω–∏–µ LogFilterRule: filterType={}, key={}, selectedAttribute={}", 
                          selectedAttributeType.equals("case") ? "CASE_CASE_ATTRIBUTE" : "EVENT_EVENT_ATTRIBUTE",
                          selectedAttribute, selectedAttribute);
            
            LOGGER.info("üîß –°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–∞–≤–∏–ª —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –¥–ª—è –∞—Ç—Ä–∏–±—É—Ç–∞: {} (—Ç–∏–ø: {})", selectedAttribute, selectedAttributeType);
            
            // –ü–æ–ª—É—á–∞–µ–º —É—Å–ª–æ–≤–∏–µ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ (Retain/Remove)
            String condition = caseAttributeCondition != null ? caseAttributeCondition.getSelectedItem().getValue() : "retain";
            Choice choice = "retain".equals(condition) ? Choice.RETAIN : Choice.REMOVE;
            
            // Determine filter type based on attribute type and selected attribute
            FilterType filterType;
            if ("event".equals(selectedAttributeType)) {
                if ("Activity".equals(selectedAttribute)) {
                    filterType = FilterType.EVENT_EVENT_ATTRIBUTE;
                    selectedAttribute = "concept:name"; // Use concept:name for Activity filtering
                } else {
                    filterType = FilterType.EVENT_EVENT_ATTRIBUTE;
                }
            } else {
                filterType = FilterType.CASE_CASE_ATTRIBUTE;
            }
            
            // –°–æ–∑–¥–∞–µ–º RuleValue –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è
            Set<RuleValue> ruleValues = new HashSet<>();
            for (String value : selectedValues) {
                Set<String> valueSet = new HashSet<>();
                valueSet.add(value);
                LOGGER.info("üîß –°–æ–∑–¥–∞–Ω–∏–µ RuleValue –¥–ª—è –∞—Ç—Ä–∏–±—É—Ç–∞: filterType={}, operationType={}, key={}, value={}", 
                           filterType, OperationType.EQUAL, selectedAttribute, value);
                RuleValue ruleValue = new RuleValue(
                    filterType,
                    OperationType.EQUAL,
                    selectedAttribute,
                    valueSet
                );
                ruleValues.add(ruleValue);
                LOGGER.info("RuleValue —Å–æ–∑–¥–∞–Ω: objectVal={}, stringVal={}, stringSetValue={}", 
                           ruleValue.getObjectVal(), ruleValue.getStringValue(), ruleValue.getStringSetValue());
            }
            
            // –°–æ–∑–¥–∞–µ–º –ø—Ä–∞–≤–∏–ª–æ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –∏—Å–ø–æ–ª—å–∑—É—è –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –Ω–∞–ø—Ä—è–º—É—é
            LogFilterRule rule = new LogFilterRuleImpl(
                choice,
                Inclusion.ANY_VALUE,
                selectedAttributeType.equals("case") ? Section.CASE : Section.EVENT,
                filterType,
                selectedAttribute,  // Pass the key here
                ruleValues,
                null
            );
            
            // Add debugging to show the created rule details
            LOGGER.info("üîß –°–æ–∑–¥–∞–Ω LogFilterRule: filterType={}, key='{}', choice={}, inclusion={}, section={}", 
                       rule.getFilterType(), rule.getKey(), rule.getChoice(), rule.getInclusion(), rule.getSection());
            
            rules.add(rule);
            LOGGER.info("–°–æ–∑–¥–∞–Ω–æ –ø—Ä–∞–≤–∏–ª–æ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏: {} –∑–Ω–∞—á–µ–Ω–∏–π, —É—Å–ª–æ–≤–∏–µ: {}, —Ç–∏–ø: {}", 
                       selectedValues.size(), condition, filterType);
            
        } catch (Exception e) {
            LOGGER.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –ø—Ä–∞–≤–∏–ª —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –∞—Ç—Ä–∏–±—É—Ç–æ–≤", e);
            LOGGER.error("–ü–æ–ª–Ω—ã–π —Å—Ç–µ–∫ –æ—à–∏–±–∫–∏:", e);
            LOGGER.error("–¢–∏–ø –æ—à–∏–±–∫–∏: {}", e.getClass().getSimpleName());
            LOGGER.error("–°–æ–æ–±—â–µ–Ω–∏–µ –æ—à–∏–±–∫–∏: {}", e.getMessage());
        }
        
        return rules;
    }
    
    /**
     * Create filter rules for Case Attribute filtering (legacy method - kept for compatibility)
     */
    private List<LogFilterRule> createCaseAttributeFilterRules(List<String> selectedValues) {
        List<LogFilterRule> rules = new ArrayList<>();
        
        try {
            // –ü–æ–ª—É—á–∞–µ–º —É—Å–ª–æ–≤–∏–µ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ (Retain/Remove)
            String condition = caseAttributeCondition != null ? caseAttributeCondition.getSelectedItem().getValue() : "retain";
            Choice choice = "retain".equals(condition) ? Choice.RETAIN : Choice.REMOVE;
            
            // –°–æ–∑–¥–∞–µ–º RuleValue –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è
            Set<RuleValue> ruleValues = new HashSet<>();
            for (String value : selectedValues) {
                Set<String> valueSet = new HashSet<>();
                valueSet.add(value);
                LOGGER.info("üîß –°–æ–∑–¥–∞–Ω–∏–µ RuleValue –¥–ª—è Case Attribute: filterType={}, operationType={}, key={}, value={}", 
                           FilterType.CASE_EVENT_ATTRIBUTE, OperationType.EQUAL, "concept:name", value);
                RuleValue ruleValue = new RuleValue(
                    FilterType.CASE_EVENT_ATTRIBUTE,
                    OperationType.EQUAL,
                    "concept:name",  // –∞—Ç—Ä–∏–±—É—Ç –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
                    valueSet
                );
                ruleValues.add(ruleValue);
                LOGGER.info("RuleValue —Å–æ–∑–¥–∞–Ω: objectVal={}, stringVal={}, stringSetValue={}", 
                           ruleValue.getObjectVal(), ruleValue.getStringValue(), ruleValue.getStringSetValue());
            }
            
            // –°–æ–∑–¥–∞–µ–º –ø—Ä–∞–≤–∏–ª–æ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –∏—Å–ø–æ–ª—å–∑—É—è —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–π –º–µ—Ç–æ–¥ init
            LogFilterRule rule = LogFilterRuleImpl.init(
                FilterType.CASE_EVENT_ATTRIBUTE,
                choice == Choice.RETAIN,
                ruleValues
            );
            
            rules.add(rule);
            LOGGER.info("–°–æ–∑–¥–∞–Ω–æ –ø—Ä–∞–≤–∏–ª–æ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ Case Attribute: {} –∑–Ω–∞—á–µ–Ω–∏–π, —É—Å–ª–æ–≤–∏–µ: {}", 
                       selectedValues.size(), condition);
            
        } catch (Exception e) {
            LOGGER.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –ø—Ä–∞–≤–∏–ª Case Attribute", e);
            LOGGER.error("–ü–æ–ª–Ω—ã–π —Å—Ç–µ–∫ –æ—à–∏–±–∫–∏:", e);
            LOGGER.error("–¢–∏–ø –æ—à–∏–±–∫–∏: {}", e.getClass().getSimpleName());
            LOGGER.error("–°–æ–æ–±—â–µ–Ω–∏–µ –æ—à–∏–±–∫–∏: {}", e.getMessage());
        }
        
        return rules;
    }
    
    /**
     * Create filter rules for Case ID filtering
     */
    private List<LogFilterRule> createCaseIdFilterRules(List<String> selectedValues) {
        List<LogFilterRule> rules = new ArrayList<>();
        
        try {
            // –ü–æ–ª—É—á–∞–µ–º —É—Å–ª–æ–≤–∏–µ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ (Retain/Remove)
            String condition = caseIdCondition != null ? caseIdCondition.getSelectedItem().getValue() : "retain";
            Choice choice = "retain".equals(condition) ? Choice.RETAIN : Choice.RETAIN;
            
            // –°–æ–∑–¥–∞–µ–º RuleValue –¥–ª—è Case ID —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
            Set<RuleValue> ruleValues = new HashSet<>();
            
            // –°–æ–∑–¥–∞–µ–º BitSet –¥–ª—è –∏–Ω–¥–µ–∫—Å–æ–≤ —Ç—Ä–∞—Å—Å
            BitSet caseIdBitSet = new BitSet(apmLog.getTraces().size());
            
            // –ó–∞–ø–æ–ª–Ω—è–µ–º customAttributes –∏ BitSet
            RuleValue ruleValue = new RuleValue(
                FilterType.CASE_ID,
                OperationType.EQUAL,
                "concept:case:id",  // –∞—Ç—Ä–∏–±—É—Ç Case ID
                caseIdBitSet  // BitSet –¥–ª—è –∏–Ω–¥–µ–∫—Å–æ–≤
            );
            
            // –î–æ–±–∞–≤–ª—è–µ–º Case ID –≤ customAttributes –∏ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ –±–∏—Ç—ã
            for (String caseId : selectedValues) {
                ruleValue.getCustomAttributes().put(caseId, caseId);
                
                // –ù–∞—Ö–æ–¥–∏–º –∏–Ω–¥–µ–∫—Å —Ç—Ä–∞—Å—Å—ã —Å —ç—Ç–∏–º Case ID
                for (int i = 0; i < apmLog.getTraces().size(); i++) {
                    if (apmLog.getTraces().get(i).getCaseId().equals(caseId)) {
                        caseIdBitSet.set(i);
                        break;
                    }
                }
            }
            
            ruleValues.add(ruleValue);
            LOGGER.info("RuleValue —Å–æ–∑–¥–∞–Ω –¥–ª—è Case ID: objectVal={}, stringVal={}, customAttributes={}, bitSetValue={}", 
                       ruleValue.getObjectVal(), ruleValue.getStringValue(), ruleValue.getCustomAttributes(), ruleValue.getBitSetValue());
            
            // –°–æ–∑–¥–∞–µ–º –ø—Ä–∞–≤–∏–ª–æ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –∏—Å–ø–æ–ª—å–∑—É—è —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–π –º–µ—Ç–æ–¥ init
            LogFilterRule rule = LogFilterRuleImpl.init(
                FilterType.CASE_ID,
                choice == Choice.RETAIN,
                ruleValues
            );
            
            rules.add(rule);
            LOGGER.info("–°–æ–∑–¥–∞–Ω–æ –ø—Ä–∞–≤–∏–ª–æ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ Case ID: {} –∑–Ω–∞—á–µ–Ω–∏–π, —É—Å–ª–æ–≤–∏–µ: {}", 
                       selectedValues.size(), condition);
            
        } catch (Exception e) {
            LOGGER.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –ø—Ä–∞–≤–∏–ª Case ID", e);
            LOGGER.error("–ü–æ–ª–Ω—ã–π —Å—Ç–µ–∫ –æ—à–∏–±–∫–∏:", e);
            LOGGER.error("–¢–∏–ø –æ—à–∏–±–∫–∏: {}", e.getClass().getSimpleName());
            LOGGER.error("–°–æ–æ–±—â–µ–Ω–∏–µ –æ—à–∏–±–∫–∏: {}", e.getMessage());
        }
        
        return rules;
    }
    
    /**
     * Create filter rules for Timeframe filtering
     */
    private List<LogFilterRule> createTimeframeFilterRules() {
        List<LogFilterRule> rules = new ArrayList<>();
        
        try {
            String condition = timeframeCondition != null ? timeframeCondition.getSelectedItem().getValue() : "retain";
            Choice choice = "retain".equals(condition) ? Choice.RETAIN : Choice.REMOVE;
            
            String containmentType = getSelectedContainmentType();
            long fromTime = getFromTime();
            long toTime = getToTime();

            // If predefined mode, override bounds with computed range
            if (isPredefinedMode()) {
                long[] rng = computePredefinedRange();
                fromTime = rng[0];
                toTime = rng[1];
            } else {
                // Adjust bounds per containment type for manual mode
                if ("start".equals(containmentType)) {
                    if (apmLog != null) toTime = apmLog.getEndTime();
                } else if ("end".equals(containmentType)) {
                    if (apmLog != null) fromTime = apmLog.getStartTime();
                }
            }

            if (toTime < fromTime) {
                long tmp = fromTime; fromTime = toTime; toTime = tmp;
            }

            LOGGER.info("Creating timeframe filter: condition={}, containment={}, fromTime={}, toTime={}",
                       condition, containmentType, fromTime, toTime);

            Set<RuleValue> ruleValues = new HashSet<>();
            FilterType filterTypeForTime;
            String key;
            if ("end".equals(containmentType)) {
                filterTypeForTime = FilterType.ENDTIME;
                key = "case:endtime";
            } else if ("contained".equals(containmentType) || "active".equals(containmentType)) {
                filterTypeForTime = FilterType.CASE_TIME;
                key = "case:timeframe";
            } else { // start
                filterTypeForTime = FilterType.STARTTIME;
                key = "case:starttime";
            }

            RuleValue fromRuleValue = new RuleValue(
                filterTypeForTime,
                OperationType.GREATER_EQUAL,
                key,
                fromTime
            );
            RuleValue toRuleValue = new RuleValue(
                filterTypeForTime,
                OperationType.LESS_EQUAL,
                key,
                toTime
            );
            ruleValues.add(fromRuleValue);
            ruleValues.add(toRuleValue);

            LogFilterRule rule = LogFilterRuleImpl.init(
                filterTypeForTime,
                choice == Choice.RETAIN,
                ruleValues
            );

            // Inclusion semantics
            if ("contained".equals(containmentType)) {
                rule = ((LogFilterRuleImpl) rule).withInclusion(Inclusion.ALL_VALUES);
            } else if ("active".equals(containmentType)) {
                rule = ((LogFilterRuleImpl) rule).withInclusion(Inclusion.ANY_VALUE);
            } else {
                // start/end: inclusion not critical, use ANY_VALUE
                rule = ((LogFilterRuleImpl) rule).withInclusion(Inclusion.ANY_VALUE);
            }

            rules.add(rule);
            LOGGER.info("Created timeframe filter rule: type={}, inclusion={}, condition={}, fromTime={}, toTime={}",
                       filterTypeForTime, (rule instanceof LogFilterRuleImpl ? ((LogFilterRuleImpl) rule).getInclusion() : null), condition, fromTime, toTime);
            
        } catch (Exception e) {
            LOGGER.error("Error creating timeframe filter rules", e);
        }
        
        return rules;
    }
    
    /**
     * Get the selected containment type
     */
    private String getSelectedContainmentType() {
        if (startInIcon != null && startInIcon.getSclass() != null && startInIcon.getSclass().contains("selected")) {
            return "start";
        } else if (endInIcon != null && endInIcon.getSclass() != null && endInIcon.getSclass().contains("selected")) {
            return "end";
        } else if (containedInIcon != null && containedInIcon.getSclass() != null && containedInIcon.getSclass().contains("selected")) {
            return "contained";
        } else if (activeInIcon != null && activeInIcon.getSclass() != null && activeInIcon.getSclass().contains("selected")) {
            return "active";
        }
        return "start";
    }
    
    /**
     * Get the from time based on date input
     */
    private long getFromTime() {
        if (fromDate != null && fromDate.getValue() != null) {
            return fromDate.getValue().getTime();
        }
        // Fallback to log start time
        if (apmLog != null) {
            return apmLog.getStartTime();
        }
        // Fallback to 1 year ago
        return System.currentTimeMillis() - (365L * 24 * 60 * 60 * 1000);
    }
    
    /**
     * Get the to time based on date input
     */
    private long getToTime() {
        if (toDate != null && toDate.getValue() != null) {
            return toDate.getValue().getTime();
        }
        // Fallback to log end time
        if (apmLog != null) {
            return apmLog.getEndTime();
        }
        // Fallback to current time
        return System.currentTimeMillis();
    }
    
    /**
     * Apply filters to the log using APMLogFilter
     */
    private APMLog applyFiltersToLog(List<LogFilterRule> filterRules) {
        try {
            if (apmLog == null) {
                LOGGER.error("APMLog –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏");
                return null;
            }
            
            LOGGER.info("–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ {} –ø—Ä–∞–≤–∏–ª —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –∫ –ª–æ–≥—É", filterRules.size());
            LOGGER.info("–¢–∏–ø —Ñ–∏–ª—å—Ç—Ä–∞: {}", currentFilter);
            LOGGER.info("–†–∞–∑–º–µ—Ä –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–≥–æ –ª–æ–≥–∞: {} —Ç—Ä–∞—Å—Å", apmLog.getTraces().size());
            
            // –°–æ–∑–¥–∞–µ–º APMLogFilter
            APMLogFilter apmLogFilter = new APMLogFilter(apmLog);
            LOGGER.info("APMLogFilter —Å–æ–∑–¥–∞–Ω —É—Å–ø–µ—à–Ω–æ");
            
            // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ñ–∏–ª—å—Ç—Ä—ã
            apmLogFilter.filter(filterRules);
            LOGGER.info("–§–∏–ª—å—Ç—Ä—ã –ø—Ä–∏–º–µ–Ω–µ–Ω—ã –∫ APMLogFilter");
            
            // –ü–æ–ª—É—á–∞–µ–º –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–Ω—ã–π –ª–æ–≥
            APMLog filteredLog;
            try {
                filteredLog = apmLogFilter.getAPMLog();
                
                LOGGER.info("–§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞:");
                LOGGER.info("   - –û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –ª–æ–≥: {} —Ç—Ä–∞—Å—Å", apmLog.getTraces().size());
                LOGGER.info("   - –û—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–Ω—ã–π –ª–æ–≥: {} —Ç—Ä–∞—Å—Å", filteredLog.getTraces().size());
                
                return filteredLog;
            } catch (EmptyInputException e) {
                LOGGER.warn("–û—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–Ω—ã–π –ª–æ–≥ –ø—É—Å—Ç: {}", e.getMessage());
                // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –ª–æ–≥ –µ—Å–ª–∏ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø—Ä–∏–≤–µ–ª–∞ –∫ –ø—É—Å—Ç–æ–º—É —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É
                return apmLog;
            }
            
        } catch (Exception e) {
            LOGGER.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–∏ —Ñ–∏–ª—å—Ç—Ä–æ–≤ –∫ –ª–æ–≥—É", e);
            LOGGER.error("–ü–æ–ª–Ω—ã–π —Å—Ç–µ–∫ –æ—à–∏–±–∫–∏:", e);
            LOGGER.error("–¢–∏–ø –æ—à–∏–±–∫–∏: {}", e.getClass().getSimpleName());
            LOGGER.error("–°–æ–æ–±—â–µ–Ω–∏–µ –æ—à–∏–±–∫–∏: {}", e.getMessage());
            return null;
        }
    }
    

    

    

    


    /**
     * Close the filter window
     */
    private void closeWindow() {
        try {
            LOGGER.info("üîß Attempting to close filter window...");
            
            // Try to close the wired window first
            if (advancedLogFilterWindow != null) {
                LOGGER.info("üîß Detaching wired advancedLogFilterWindow");
                advancedLogFilterWindow.detach();
                LOGGER.info("üîß Wired window detached successfully");
            } else {
                LOGGER.warn("‚ö†Ô∏è advancedLogFilterWindow is null, trying alternative approach");
            }
            
            // Also try to find and detach any window with the logFilterWindow ID
            try {
                org.zkoss.zk.ui.Desktop desktop = org.zkoss.zk.ui.Executions.getCurrent().getDesktop();
                if (desktop != null) {
                    for (org.zkoss.zk.ui.Page page : desktop.getPages()) {
                        org.zkoss.zk.ui.Component window = page.getFellowIfAny("logFilterWindow");
                        if (window != null) {
                            LOGGER.info("üîß Found logFilterWindow component, detaching...");
                            window.detach();
                            LOGGER.info("üîß Alternative window detachment successful");
                        }
                    }
                }
            } catch (Exception e) {
                LOGGER.warn("‚ö†Ô∏è Alternative window detachment failed: {}", e.getMessage());
            }
            
            LOGGER.info("‚úÖ Filter window close operation completed");
        } catch (Exception e) {
            LOGGER.error("‚ùå Error closing window", e);
        }
    }
    
    /**
     * Configure the top-left button behavior based on whether this is first or secondary filter window
     */
    private void configureTopLeftButton() {
        try {
            if (filterTopLeftBtn != null) {
                filterTopLeftBtn.setLabel("\u2190");
                
                // Check if this is a secondary filter window (has existing criteria)
                boolean hasExistingCriteria = (currentCriteria != null && !currentCriteria.isEmpty()) || 
                                             (criteriaDescriptionsFromArgs != null && !criteriaDescriptionsFromArgs.isEmpty());
                
                LOGGER.info("üîß Configuring top-left button. Has existing criteria: {}", hasExistingCriteria);
                
                if (hasExistingCriteria) {
                    // Secondary filter window: go back to criteria window
                    filterTopLeftBtn.addEventListener(Events.ON_CLICK, e -> goBackToCriteriaWindow());
                    LOGGER.info("üîß Top-left button configured for secondary filter (back to criteria)");
                } else {
                    // First filter window: close the window
                    filterTopLeftBtn.addEventListener(Events.ON_CLICK, e -> closeWindow());
                    LOGGER.info("üîß Top-left button configured for first filter (close window)");
                }
            }
        } catch (Exception e) {
            LOGGER.error("‚ùå Error configuring top-left button", e);
        }
    }

    /**
     * Go back to the criteria window (for secondary filter windows)
     */
    private void goBackToCriteriaWindow() {
        try {
            LOGGER.info("üîß Going back to criteria window from secondary filter...");
            
            // Close current filter window
            closeWindow();
            
            // Reopen criteria window with existing criteria
            java.util.Map<String, Object> args = new java.util.HashMap<>();
            args.put("criteriaDescriptions", criteriaDescriptionsFromArgs);
            args.put("criteriaRules", currentCriteria);
            // pass-through original context
            if (this.portalContext != null) args.put("portalContext", this.portalContext);
            if (this.selectedLog != null) args.put("selectedLog", this.selectedLog);
            if (this.logName != null) args.put("logName", this.logName);
            if (this.logId != null) args.put("logId", this.logId);
            if (this.apmLog != null) args.put("apmLog", this.apmLog);
            if (this.logFilterClient != null) args.put("logFilterClient", this.logFilterClient);
            
            // Open criteria window
            org.zkoss.zul.Window w = null;
            if (portalContext != null && portalContext.getUI() != null) {
                w = (org.zkoss.zul.Window) portalContext.getUI()
                        .createComponent(getClass().getClassLoader(), "filterCriteria.zul", null, args);
            } else {
                w = (org.zkoss.zul.Window) org.zkoss.zk.ui.Executions.getCurrent()
                        .createComponentsDirectly(
                                new java.io.InputStreamReader(
                                        getClass().getClassLoader().getResourceAsStream("filterCriteria.zul"),
                                        java.nio.charset.StandardCharsets.UTF_8),
                                "zul", null, args);
            }
            if (w != null) {
                w.doModal();
                LOGGER.info("‚úÖ Criteria window reopened successfully");
            }
            
        } catch (Exception e) {
            LOGGER.error("‚ùå Error going back to criteria window", e);
            Messagebox.show("Error returning to criteria window: " + e.getMessage(), 
                          "Error", Messagebox.OK, Messagebox.ERROR);
        }
    }
    
    /**
     * Display specific page of attribute values
     */
    private void displayAttributePage(int page) {
        try {
            LOGGER.info("üîÑ === –ù–ê–ß–ê–õ–û displayAttributePage({}) ===", page);
            if (attributeValuesList == null) {
                LOGGER.error("‚ùå attributeValuesList == null");
                return;
            }
            
            LOGGER.info("üîÑ –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã {} –∞—Ç—Ä–∏–±—É—Ç–æ–≤, –≤—Å–µ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤: {}", page, allAttributeValues.size());
            
            attributeValuesList.getItems().clear();
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
            if (allAttributeValues.isEmpty()) {
                LOGGER.warn("‚ö†Ô∏è allAttributeValues –ø—É—Å—Ç, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã (–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö)");
                // Avoid recursive call leading to StackOverflow; the data loader is invoked elsewhere
                return;
            }
            
            int totalPages = (int) Math.ceil((double) allAttributeValues.size() / ITEMS_PER_PAGE);
            int startIndex = (page - 1) * ITEMS_PER_PAGE;
            int endIndex = Math.min(startIndex + ITEMS_PER_PAGE, allAttributeValues.size());
            
            // –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –∞—Ç—Ä–∏–±—É—Ç–∞
            Map<String, Integer> attributeValueCounts = new HashMap<>();
            if (apmLog != null && primaryAttributeCombo != null) {
                Comboitem selectedItem = primaryAttributeCombo.getSelectedItem();
                if (selectedItem == null) {
                    LOGGER.error("‚ùå –ù–µ—Ç –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –≤ primaryAttributeCombo");
                    return;
                }
                
                String selectedAttribute = (selectedItem.getValue() != null) ? String.valueOf(selectedItem.getValue()) : selectedItem.getLabel();
                LOGGER.info("üîß –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∞—Ç—Ä–∏–±—É—Ç–∞: {}", selectedAttribute);
                
                // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø –∞—Ç—Ä–∏–±—É—Ç–∞ (case –∏–ª–∏ event) –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞ –≤ radio button
                String selectedAttributeType = "event"; // default to event
                if (primaryAttributeType != null && primaryAttributeType.getSelectedItem() != null) {
                    selectedAttributeType = primaryAttributeType.getSelectedItem().getValue();
                }
                
                boolean isCaseAttribute = "case".equals(selectedAttributeType);
                
                LOGGER.info("üîß –¢–∏–ø –∞—Ç—Ä–∏–±—É—Ç–∞: {}", isCaseAttribute ? "CASE" : "EVENT");
                
                if (isCaseAttribute) {
                    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º case attributes
                    for (ATrace trace : apmLog.getTraces()) {
                        if (trace.getAttributes() != null && trace.getAttributes().containsKey(selectedAttribute)) {
                            String value = trace.getAttributes().get(selectedAttribute).toString();
                            if (value != null && !value.isEmpty()) {
                                attributeValueCounts.put(value, attributeValueCounts.getOrDefault(value, 0) + 1);
                            }
                        }
                    }
                } else {
                    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º event attributes
                    if (selectedAttribute.equals("Activity")) {
                        // Special handling for Activity: count cases (traces) that contain each activity
                        LOGGER.info("üîß –°–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –¥–ª—è Activity...");
                        for (ATrace trace : apmLog.getTraces()) {
                            Set<String> activitiesInTrace = new HashSet<>();
                            for (ActivityInstance activityInstance : trace.getActivityInstances()) {
                                String activityName = activityInstance.getName();
                                if (activityName != null && !activityName.isEmpty()) {
                                    activitiesInTrace.add(activityName);
                                }
                            }
                            // Count each activity once per trace (case)
                            for (String activityName : activitiesInTrace) {
                                attributeValueCounts.put(activityName, attributeValueCounts.getOrDefault(activityName, 0) + 1);
                            }
                        }
                        LOGGER.info("üîß –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ Activity: –∫–∞–∂–¥–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –ø–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ—Ç—Å—è –æ–¥–∏–Ω —Ä–∞–∑ –Ω–∞ —Å–ª—É—á–∞–π");
                    } else {
                        // Regular event attributes: count each occurrence
                        for (ATrace trace : apmLog.getTraces()) {
                            for (ActivityInstance activityInstance : trace.getActivityInstances()) {
                                if (activityInstance.getAttributes() != null && 
                                    activityInstance.getAttributes().containsKey(selectedAttribute)) {
                                    String value = activityInstance.getAttributes().get(selectedAttribute).toString();
                                    if (value != null && !value.isEmpty()) {
                                        attributeValueCounts.put(value, attributeValueCounts.getOrDefault(value, 0) + 1);
                                    }
                                }
                            }
                        }
                    }
                }
                
                LOGGER.info("üîß –ù–∞–π–¥–µ–Ω–æ {} —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π –∞—Ç—Ä–∏–±—É—Ç–∞ '{}'", attributeValueCounts.size(), selectedAttribute);
            }
            
            // Calculate total cases correctly based on attribute type
            int totalCases;
            if (apmLog != null && primaryAttributeCombo != null) {
                Comboitem selectedItem = primaryAttributeCombo.getSelectedItem();
                if (selectedItem != null) {
                    String selectedAttribute = (selectedItem.getValue() != null) ? String.valueOf(selectedItem.getValue()) : selectedItem.getLabel();
                    
                    if (selectedAttribute.equals("Activity")) {
                        // For Activity: use total number of cases in the log
                        totalCases = apmLog.getTraces().size();
                        LOGGER.info("üîß –î–ª—è Activity –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–ª—É—á–∞–µ–≤ –≤ –ª–æ–≥–µ: {}", totalCases);
                    } else {
                        // For other attributes: use sum of attribute counts (existing logic)
                        totalCases = attributeValueCounts.values().stream().mapToInt(Integer::intValue).sum();
                        LOGGER.info("üîß –î–ª—è –¥—Ä—É–≥–∏—Ö –∞—Ç—Ä–∏–±—É—Ç–æ–≤ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—É–º–º—É –∑–Ω–∞—á–µ–Ω–∏–π: {}", totalCases);
                    }
                } else {
                    totalCases = attributeValueCounts.values().stream().mapToInt(Integer::intValue).sum();
                    LOGGER.info("üîß Fallback: –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–ª—É—á–∞–µ–≤: {}", totalCases);
                }
            } else {
                totalCases = attributeValueCounts.values().stream().mapToInt(Integer::intValue).sum();
                LOGGER.info("üîß Fallback: –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–ª—É—á–∞–µ–≤: {}", totalCases);
            }
            
            // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã —Ç–µ–∫—É—â–µ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã
            LOGGER.info("üîß –ù–∞—á–∏–Ω–∞–µ–º –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤ —Ç–∞–±–ª–∏—Ü—É...");
            int addedItems = 0;
            for (int i = startIndex; i < endIndex; i++) {
                String attributeValue = allAttributeValues.get(i);
                int count = attributeValueCounts.getOrDefault(attributeValue, 0);
                double frequency = totalCases > 0 ? (double) count / totalCases * 100 : 0.0;
                
                LOGGER.info("üîß –î–æ–±–∞–≤–ª—è–µ–º —ç–ª–µ–º–µ–Ω—Ç {}: –∑–Ω–∞—á–µ–Ω–∏–µ='{}', –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ={}, —á–∞—Å—Ç–æ—Ç–∞={:.2f}%", 
                           i + 1, attributeValue, count, frequency);
                
                addAttributeValue(attributeValue, count, frequency);
                addedItems++;
            }
            
            LOGGER.info("üîß –î–æ–±–∞–≤–ª–µ–Ω–æ {} —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤ —Ç–∞–±–ª–∏—Ü—É", addedItems);
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –ø–∞–≥–∏–Ω–∞—Ü–∏—é
            updateAttributePagination(page, totalPages, startIndex + 1, endIndex);
            
            LOGGER.info("‚úÖ –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–∞ {} –∑–Ω–∞—á–µ–Ω–∏–π –∞—Ç—Ä–∏–±—É—Ç–∞ (—ç–ª–µ–º–µ–Ω—Ç—ã {}-{})", page, startIndex + 1, endIndex);
            LOGGER.info("üîÑ === –ö–û–ù–ï–¶ displayAttributePage({}) ===", page);
            
        } catch (Exception e) {
            LOGGER.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã –∑–Ω–∞—á–µ–Ω–∏–π –∞—Ç—Ä–∏–±—É—Ç–∞", e);
        }
    }
    
    /**
     * Update attribute pagination controls
     */
    private void updateAttributePagination(int currentPage, int totalPages, int startItem, int endItem) {
        try {
            LOGGER.info("–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–∞–≥–∏–Ω–∞—Ü–∏–∏ –∞—Ç—Ä–∏–±—É—Ç–æ–≤: —Å—Ç—Ä–∞–Ω–∏—Ü–∞ {}/{}, —ç–ª–µ–º–µ–Ω—Ç—ã {}-{}", currentPage, totalPages, startItem, endItem);
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –∫–Ω–æ–ø–∫–∏ –Ω–∞–ø—Ä—è–º—É—é
            if (firstPageBtn != null) {
                firstPageBtn.setDisabled(currentPage <= 1);
                LOGGER.debug("–ö–Ω–æ–ø–∫–∞ '–ü–µ—Ä–≤–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞' {}disabled", firstPageBtn.isDisabled() ? "" : "–Ω–µ ");
            }
            if (prevPageBtn != null) {
                prevPageBtn.setDisabled(currentPage <= 1);
                LOGGER.debug("–ö–Ω–æ–ø–∫–∞ '–ü—Ä–µ–¥—ã–¥—É—â–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞' {}disabled", prevPageBtn.isDisabled() ? "" : "–Ω–µ ");
            }
            if (nextPageBtn != null) {
                nextPageBtn.setDisabled(currentPage >= totalPages);
                LOGGER.debug("–ö–Ω–æ–ø–∫–∞ '–°–ª–µ–¥—É—é—â–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞' {}disabled", nextPageBtn.isDisabled() ? "" : "–Ω–µ ");
            }
            if (lastPageBtn != null) {
                lastPageBtn.setDisabled(currentPage >= totalPages);
                LOGGER.debug("–ö–Ω–æ–ø–∫–∞ '–ü–æ—Å–ª–µ–¥–Ω—è—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞' {}disabled", lastPageBtn.isDisabled() ? "" : "–Ω–µ ");
            }
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –º–µ—Ç–∫–∏ –Ω–∞–ø—Ä—è–º—É—é
            if (pageLabel != null) {
                pageLabel.setValue(currentPage + " / " + totalPages);
                LOGGER.debug("–ú–µ—Ç–∫–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—ã –æ–±–Ω–æ–≤–ª–µ–Ω–∞: {}", pageLabel.getValue());
            }
            if (pageInfo != null) {
                pageInfo.setValue("–°—Ç—Ä–∞–Ω–∏—Ü–∞ " + currentPage);
                LOGGER.debug("–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å—Ç—Ä–∞–Ω–∏—Ü–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∞: {}", pageInfo.getValue());
            }
            if (totalInfo != null) {
                totalInfo.setValue(startItem + " - " + endItem + " / " + allAttributeValues.size());
                LOGGER.debug("–û–±—â–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∞: {}", totalInfo.getValue());
            }
            
            LOGGER.info("–ü–∞–≥–∏–Ω–∞—Ü–∏—è –∞—Ç—Ä–∏–±—É—Ç–æ–≤ –æ–±–Ω–æ–≤–ª–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ");
            
        } catch (Exception e) {
            LOGGER.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø–∞–≥–∏–Ω–∞—Ü–∏–∏ –∞—Ç—Ä–∏–±—É—Ç–æ–≤", e);
        }
    }
    
    /**
     * Pagination event handlers for attributes
     */
    @Listen("onClick = #firstPageBtn")
    public void onFirstPage() {
        try {
            LOGGER.info("–ü–µ—Ä–µ—Ö–æ–¥ –Ω–∞ –ø–µ—Ä–≤—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É –∞—Ç—Ä–∏–±—É—Ç–æ–≤");
            if (currentAttributePage > 1) {
                currentAttributePage = 1;
                displayAttributePage(currentAttributePage);
            }
        } catch (Exception e) {
            LOGGER.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –Ω–∞ –ø–µ—Ä–≤—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É –∞—Ç—Ä–∏–±—É—Ç–æ–≤", e);
        }
    }
    
    @Listen("onClick = #prevPageBtn")
    public void onPrevPage() {
        try {
            LOGGER.info("–ü–µ—Ä–µ—Ö–æ–¥ –Ω–∞ –ø—Ä–µ–¥—ã–¥—É—â—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É –∞—Ç—Ä–∏–±—É—Ç–æ–≤");
            if (currentAttributePage > 1) {
                currentAttributePage--;
                displayAttributePage(currentAttributePage);
            }
        } catch (Exception e) {
            LOGGER.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –Ω–∞ –ø—Ä–µ–¥—ã–¥—É—â—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É –∞—Ç—Ä–∏–±—É—Ç–æ–≤", e);
        }
    }
    
    @Listen("onClick = #nextPageBtn")
    public void onNextPage() {
        try {
            LOGGER.info("–ü–µ—Ä–µ—Ö–æ–¥ –Ω–∞ —Å–ª–µ–¥—É—é—â—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É –∞—Ç—Ä–∏–±—É—Ç–æ–≤");
            int totalPages = (int) Math.ceil((double) allAttributeValues.size() / ITEMS_PER_PAGE);
            if (currentAttributePage < totalPages) {
                currentAttributePage++;
                displayAttributePage(currentAttributePage);
            }
        } catch (Exception e) {
            LOGGER.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –Ω–∞ —Å–ª–µ–¥—É—é—â—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É –∞—Ç—Ä–∏–±—É—Ç–æ–≤", e);
        }
    }
    
    @Listen("onClick = #lastPageBtn")
    public void onLastPage() {
        try {
            LOGGER.info("–ü–µ—Ä–µ—Ö–æ–¥ –Ω–∞ –ø–æ—Å–ª–µ–¥–Ω—é—é —Å—Ç—Ä–∞–Ω–∏—Ü—É –∞—Ç—Ä–∏–±—É—Ç–æ–≤");
            int totalPages = (int) Math.ceil((double) allAttributeValues.size() / ITEMS_PER_PAGE);
            if (currentAttributePage < totalPages) {
                currentAttributePage = totalPages;
                displayAttributePage(currentAttributePage);
            }
        } catch (Exception e) {
            LOGGER.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –Ω–∞ –ø–æ—Å–ª–µ–¥–Ω—é—é —Å—Ç—Ä–∞–Ω–∏—Ü—É –∞—Ç—Ä–∏–±—É—Ç–æ–≤", e);
        }
    }
    
    /**
     * Display specific page of case IDs
     */
    private void displayCaseIdPage(int page) {
        try {
            if (caseIdValuesList == null) {
                LOGGER.warn("caseIdValuesList –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω");
                return;
            }
            
            LOGGER.info("–û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã {} Case ID (–≤—Å–µ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤: {})", page, allCaseIdValues.size());
            
            caseIdValuesList.getItems().clear();
            
            if (allCaseIdValues.isEmpty()) {
                LOGGER.warn("–°–ø–∏—Å–æ–∫ Case ID –ø—É—Å—Ç, –∑–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∑–∞–Ω–æ–≤–æ");
                loadCaseIdsForLog();
                return;
            }
            
            int totalPages = (int) Math.ceil((double) allCaseIdValues.size() / ITEMS_PER_PAGE);
            int startIndex = (page - 1) * ITEMS_PER_PAGE;
            int endIndex = Math.min(startIndex + ITEMS_PER_PAGE, allCaseIdValues.size());
            
            // –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
            Map<String, Integer> caseIdCounts = new HashMap<>();
            if (apmLog != null) {
                for (ATrace trace : apmLog.getTraces()) {
                    String caseId = trace.getCaseId();
                    if (caseId != null && !caseId.isEmpty()) {
                        int eventCount = trace.getActivityInstances().size();
                        caseIdCounts.put(caseId, eventCount);
                    }
                }
            }
            
            // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã —Ç–µ–∫—É—â–µ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã
            for (int i = startIndex; i < endIndex; i++) {
                String caseId = allCaseIdValues.get(i);
                int eventCount = caseIdCounts.getOrDefault(caseId, 0);
                addCaseId(caseId, eventCount);
            }
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –ø–∞–≥–∏–Ω–∞—Ü–∏—é
            updateCaseIdPagination(page, totalPages, startIndex + 1, endIndex);
            
            LOGGER.info("–û—Ç–æ–±—Ä–∞–∂–µ–Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–∞ {} Case ID (—ç–ª–µ–º–µ–Ω—Ç—ã {}-{})", page, startIndex + 1, endIndex);
            
        } catch (Exception e) {
            LOGGER.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã Case ID", e);
        }
    }
    
    /**
     * Update case ID pagination controls
     */
    private void updateCaseIdPagination(int currentPage, int totalPages, int startItem, int endItem) {
        try {
            LOGGER.info("–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–∞–≥–∏–Ω–∞—Ü–∏–∏ Case ID: —Å—Ç—Ä–∞–Ω–∏—Ü–∞ {}/{}, —ç–ª–µ–º–µ–Ω—Ç—ã {}-{}", currentPage, totalPages, startItem, endItem);
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –∫–Ω–æ–ø–∫–∏ –Ω–∞–ø—Ä—è–º—É—é
            if (caseIdFirstPageBtn != null) {
                caseIdFirstPageBtn.setDisabled(currentPage <= 1);
                LOGGER.debug("–ö–Ω–æ–ø–∫–∞ '–ü–µ—Ä–≤–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ Case ID' {}disabled", caseIdFirstPageBtn.isDisabled() ? "" : "–Ω–µ ");
            }
            if (caseIdPrevPageBtn != null) {
                caseIdPrevPageBtn.setDisabled(currentPage <= 1);
                LOGGER.debug("–ö–Ω–æ–ø–∫–∞ '–ü—Ä–µ–¥—ã–¥—É—â–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ Case ID' {}disabled", caseIdPrevPageBtn.isDisabled() ? "" : "–Ω–µ ");
            }
            if (caseIdNextPageBtn != null) {
                caseIdNextPageBtn.setDisabled(currentPage >= totalPages);
                LOGGER.debug("–ö–Ω–æ–ø–∫–∞ '–°–ª–µ–¥—É—é—â–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ Case ID' {}disabled", caseIdNextPageBtn.isDisabled() ? "" : "–Ω–µ ");
            }
            if (caseIdLastPageBtn != null) {
                caseIdLastPageBtn.setDisabled(currentPage >= totalPages);
                LOGGER.debug("–ö–Ω–æ–ø–∫–∞ '–ü–æ—Å–ª–µ–¥–Ω—è—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ Case ID' {}disabled", caseIdLastPageBtn.isDisabled() ? "" : "–Ω–µ ");
            }
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –º–µ—Ç–∫–∏ –Ω–∞–ø—Ä—è–º—É—é
            if (caseIdPageLabel != null) {
                caseIdPageLabel.setValue(currentPage + " / " + totalPages);
                LOGGER.debug("–ú–µ—Ç–∫–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—ã Case ID –æ–±–Ω–æ–≤–ª–µ–Ω–∞: {}", caseIdPageLabel.getValue());
            }
            if (caseIdPageInfo != null) {
                caseIdPageInfo.setValue("–°—Ç—Ä–∞–Ω–∏—Ü–∞ " + currentPage);
                LOGGER.debug("–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å—Ç—Ä–∞–Ω–∏—Ü–µ Case ID –æ–±–Ω–æ–≤–ª–µ–Ω–∞: {}", caseIdPageInfo.getValue());
            }
            if (caseIdTotalInfo != null) {
                caseIdTotalInfo.setValue(startItem + " - " + endItem + " / " + allCaseIdValues.size());
                LOGGER.debug("–û–±—â–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è Case ID –æ–±–Ω–æ–≤–ª–µ–Ω–∞: {}", caseIdTotalInfo.getValue());
            }
            
            LOGGER.info("–ü–∞–≥–∏–Ω–∞—Ü–∏—è Case ID –æ–±–Ω–æ–≤–ª–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ");
            
        } catch (Exception e) {
            LOGGER.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø–∞–≥–∏–Ω–∞—Ü–∏–∏ Case ID", e);
        }
    }
    
    /**
     * Pagination event handlers for case IDs
     */
    @Listen("onClick = #caseIdFirstPageBtn")
    public void onCaseIdFirstPage() {
        try {
            LOGGER.info("–ü–µ—Ä–µ—Ö–æ–¥ –Ω–∞ –ø–µ—Ä–≤—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É Case ID");
            if (currentCaseIdPage > 1) {
                currentCaseIdPage = 1;
                displayCaseIdPage(currentCaseIdPage);
            }
        } catch (Exception e) {
            LOGGER.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –Ω–∞ –ø–µ—Ä–≤—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É Case ID", e);
        }
    }
    
    @Listen("onClick = #caseIdPrevPageBtn")
    public void onCaseIdPrevPage() {
        try {
            LOGGER.info("–ü–µ—Ä–µ—Ö–æ–¥ –Ω–∞ –ø—Ä–µ–¥—ã–¥—É—â—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É Case ID");
            if (currentCaseIdPage > 1) {
                currentCaseIdPage--;
                displayCaseIdPage(currentCaseIdPage);
            }
        } catch (Exception e) {
            LOGGER.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –Ω–∞ –ø—Ä–µ–¥—ã–¥—É—â—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É Case ID", e);
        }
    }
    
    @Listen("onClick = #caseIdNextPageBtn")
    public void onCaseIdNextPage() {
        try {
            LOGGER.info("–ü–µ—Ä–µ—Ö–æ–¥ –Ω–∞ —Å–ª–µ–¥—É—é—â—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É Case ID");
            int totalPages = (int) Math.ceil((double) allCaseIdValues.size() / ITEMS_PER_PAGE);
            if (currentCaseIdPage < totalPages) {
                currentCaseIdPage++;
                displayCaseIdPage(currentCaseIdPage);
            }
        } catch (Exception e) {
            LOGGER.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –Ω–∞ —Å–ª–µ–¥—É—é—â—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É Case ID", e);
        }
    }
    
    @Listen("onClick = #caseIdLastPageBtn")
    public void onCaseIdLastPage() {
        try {
            LOGGER.info("–ü–µ—Ä–µ—Ö–æ–¥ –Ω–∞ –ø–æ—Å–ª–µ–¥–Ω—é—é —Å—Ç—Ä–∞–Ω–∏—Ü—É Case ID");
            int totalPages = (int) Math.ceil((double) allCaseIdValues.size() / ITEMS_PER_PAGE);
            if (currentCaseIdPage < totalPages) {
                currentCaseIdPage = totalPages;
                displayCaseIdPage(currentCaseIdPage);
            }
        } catch (Exception e) {
            LOGGER.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –Ω–∞ –ø–æ—Å–ª–µ–¥–Ω—é—é —Å—Ç—Ä–∞–Ω–∏—Ü—É Case ID", e);
        }
    }

    /**
     * Show intervals dialog for predefined timeframes
     */
    private void showIntervalsDialog(String timeframeType) {
        try {
            // Create a simple dialog to show available intervals
            String message = "Available " + timeframeType + " intervals:\n";
            message += "This would show a list of available intervals based on the log data.";
            
            Messagebox.show(message, "Intervals for " + timeframeType, 
                          Messagebox.OK, Messagebox.INFORMATION);
            
            LOGGER.info("Showing intervals dialog for timeframe type: {}", timeframeType);
        } catch (Exception e) {
            LOGGER.error("Error showing intervals dialog", e);
        }
    }
    
    /**
     * Initialize the time chart with log data
     */
    private void initializeTimeChart() {
        try {
            LOGGER.info("Starting time range display initialization...");
            
            if (apmLog == null) {
                LOGGER.warn("Cannot initialize time range display: APMLog is null");
                return;
            }
            
            // Get time range from log
            long startTime = apmLog.getStartTime();
            long endTime = apmLog.getEndTime();
            
            LOGGER.info("Initializing time range display with log data: startTime={}, endTime={}", startTime, endTime);
            
            // Update the time range display labels
            if (timeRangeDisplay != null) {
                String timeRangeText = formatTime(startTime) + " to " + formatTime(endTime);
                timeRangeDisplay.setValue(timeRangeText);
            }
            
            if (caseCountDisplay != null) {
                caseCountDisplay.setValue(apmLog.getTraces().size() + " cases");
            }
            
            LOGGER.info("Time range display initialized successfully");
            
        } catch (Exception e) {
            LOGGER.error("Error initializing time range display", e);
        }
    }
    
    /**
     * Format timestamp to readable string
     */
    private String formatTime(long timestamp) {
        try {
            java.util.Date date = new java.util.Date(timestamp);
            java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat("dd MMM yy, HH:mm:ss");
            return sdf.format(date);
        } catch (Exception e) {
            return "Unknown";
        }
    }
    
    /**
     * Format duration to readable string
     */
    private String formatDuration(long duration) {
        try {
            long years = duration / (365L * 24 * 60 * 60 * 1000);
            if (years > 0) {
                return years + " yrs";
            }
            
            long months = duration / (30L * 24 * 60 * 60 * 1000);
            if (months > 0) {
                return months + " months";
            }
            
            long days = duration / (24L * 60 * 60 * 1000);
            if (days > 0) {
                return days + " days";
            }
            
            long hours = duration / (60L * 60 * 1000);
            if (hours > 0) {
                return hours + " hrs";
            }
            
            return "Less than 1 hour";
        } catch (Exception e) {
            return "Unknown";
        }
    }
    
    /**
     * Format time axis with multiple time points
     */
    private String formatTimeAxis(long startTime, long endTime) {
        try {
            long duration = endTime - startTime;
            long interval = duration / 4; // 5 points total
            
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i <= 4; i++) {
                if (i > 0) sb.append(" - ");
                long time = startTime + (i * interval);
                sb.append(formatTime(time));
            }
            return sb.toString();
        } catch (Exception e) {
            return "Time axis unavailable";
        }
    }
    
    /**
     * Set containment icon as selected
     */
    private void setContainmentIcon(String containmentType) {
        try {
            // Reset all icons to inactive
            if (startInIcon != null) startInIcon.setSclass("containment-icon inactive");
            if (endInIcon != null) endInIcon.setSclass("containment-icon inactive");
            if (containedInIcon != null) containedInIcon.setSclass("containment-icon inactive");
            if (activeInIcon != null) activeInIcon.setSclass("containment-icon inactive");
            
            // Set selected icon
            switch (containmentType) {
                case "start":
                    if (startInIcon != null) startInIcon.setSclass("containment-icon selected");
                    break;
                case "end":
                    if (endInIcon != null) endInIcon.setSclass("containment-icon selected");
                    break;
                case "contained":
                    if (containedInIcon != null) containedInIcon.setSclass("containment-icon selected");
                    break;
                case "active":
                    if (activeInIcon != null) activeInIcon.setSclass("containment-icon selected");
                    break;
            }

            // Ensure visual styles reflect state
            refreshContainmentIconStyles();
            
            LOGGER.info("Containment icon set to: {}", containmentType);
        } catch (Exception e) {
            LOGGER.error("Error setting containment icon", e);
        }
    }
    
    /**
     * Create or update the time range display dynamically
     */
    private void createOrUpdateTimeRangeDisplay(long startTime, long endTime) {
        try {
            if (apmLog == null) {
                LOGGER.warn("Cannot create time range display: APMLog is null");
                return;
            }
            
            if (timeframePanel == null) {
                LOGGER.warn("Cannot create time range display: timeframePanel is null");
                return;
            }
            
            LOGGER.info("Creating/updating time range display for log with {} traces", apmLog.getTraces().size());
            
            // Find the container div for the time range display
            Component timeRangeContainer = timeframePanel.query("#time-chart-container");
            if (timeRangeContainer == null) {
                LOGGER.warn("Could not find time-chart-container in timeframe panel");
                return;
            }
            
            // Look for existing labels or create new ones
            Label timeRangeLabel = null;
            Label caseCountLabel = null;
            
            // Try to find existing labels
            for (Component child : timeRangeContainer.getChildren()) {
                if (child instanceof Label) {
                    Label label = (Label) child;
                    if (label.getId() != null && label.getId().equals("timeRangeDisplay")) {
                        timeRangeLabel = label;
                    } else if (label.getId() != null && label.getId().equals("caseCountDisplay")) {
                        caseCountLabel = label;
                    }
                }
            }
            
            // Create time range label if not found
            if (timeRangeLabel == null) {
                timeRangeLabel = new Label();
                timeRangeLabel.setId("timeRangeDisplay");
                timeRangeLabel.setStyle("color: #333; font-size: 14px; text-align: center; margin: 10px 0;");
                timeRangeContainer.appendChild(timeRangeLabel);
                LOGGER.info("Created new timeRangeDisplay label");
            }
            
            // Create case count label if not found
            if (caseCountLabel == null) {
                caseCountLabel = new Label();
                caseCountLabel.setId("caseCountDisplay");
                caseCountLabel.setStyle("color: #666; font-size: 12px; margin-top: 5px;");
                timeRangeContainer.appendChild(caseCountLabel);
                LOGGER.info("Created new caseCountDisplay label");
            }
            
            // Update the labels with actual data
            String timeRangeText = formatTime(startTime) + " to " + formatTime(endTime);
            timeRangeLabel.setValue(timeRangeText);
            caseCountLabel.setValue(apmLog.getTraces().size() + " cases");
            
            LOGGER.info("Time range display updated: {} cases, range: {}", apmLog.getTraces().size(), timeRangeText);
            
        } catch (Exception e) {
            LOGGER.error("Error creating/updating time range display", e);
        }
    }

    private void applyContainmentIconStyle(Div icon, boolean selected) {
        if (icon == null) return;
        String color = selected ? "#337ab7" : "#ccc";
        icon.setStyle("width: 30px; height: 30px; border: 2px solid " + color + "; border-radius: 4px; display: flex; align-items: center; justify-content: center; font-weight: bold; color: " + color + "; cursor: pointer;");
    }

    private void refreshContainmentIconStyles() {
        applyContainmentIconStyle(startInIcon, startInIcon != null && startInIcon.getSclass() != null && startInIcon.getSclass().contains("selected"));
        applyContainmentIconStyle(endInIcon, endInIcon != null && endInIcon.getSclass() != null && endInIcon.getSclass().contains("selected"));
        applyContainmentIconStyle(containedInIcon, containedInIcon != null && containedInIcon.getSclass() != null && containedInIcon.getSclass().contains("selected"));
        applyContainmentIconStyle(activeInIcon, activeInIcon != null && activeInIcon.getSclass() != null && activeInIcon.getSclass().contains("selected"));
    }

    @Listen("onCheck = #usePredefinedTimeframes")
    public void onUsePredefinedTimeframesToggle() {
        try {
            if (predefinedTimeframesLayout != null && usePredefinedTimeframes != null) {
                boolean checked = usePredefinedTimeframes.isChecked();
                predefinedTimeframesLayout.setVisible(checked);
                disableManualDates(checked);
                setContainmentLocked(checked);
            }
        } catch (Exception e) {
            LOGGER.error("Error toggling predefined timeframes", e);
        }
    }

    @Listen("onClick = #intervalsBtn")
    public void onIntervalsBtnClick() {
        try {
            if (predefinedTimeframeType == null || predefinedTimeframeType.getSelectedItem() == null) {
                Messagebox.show("Please select a timeframe type first", "Predefined timeframes", Messagebox.OK, Messagebox.EXCLAMATION);
                return;
            }
            selectedPredefinedType = predefinedTimeframeType.getSelectedItem().getLabel();

            // Build a simple window with a listbox of intervals (placeholder)
            Window w = new Window("Select Intervals", "normal", true);
            w.setWidth("360px");
            w.setClosable(true);
            w.setSclass("intervals-window");
            Listbox lb = new Listbox();
            lb.setMold("select");
            lb.setMultiple(true);
            lb.setCheckmark(true);
            lb.setWidth("320px");
            lb.setHeight("260px");

            // Populate items based on selected type and log boundaries
            List<String> intervals = computeIntervalsForType(selectedPredefinedType);
            for (String it : intervals) {
                Listitem li = new Listitem(it);
                lb.appendChild(li);
                if (selectedPredefinedIntervals.contains(it)) {
                    li.setSelected(true);
                }
            }
            w.appendChild(lb);

            Hlayout actions = new Hlayout();
            actions.setSpacing("10px");
            Button ok = new Button("OK");
            ok.addEventListener("onClick", evt -> {
                selectedPredefinedIntervals.clear();
                for (Listitem sel : lb.getSelectedItems()) {
                    selectedPredefinedIntervals.add(sel.getLabel());
                }
                w.detach();
                LOGGER.info("Selected predefined intervals ({}): {}", selectedPredefinedType, selectedPredefinedIntervals);
            });
            Button cancel = new Button("Cancel");
            cancel.addEventListener("onClick", evt -> w.detach());
            actions.appendChild(ok);
            actions.appendChild(cancel);
            w.appendChild(actions);

            // Attach modal to main window if available
            if (advancedLogFilterWindow != null) {
                w.setParent(advancedLogFilterWindow);
            } else {
                w.setParent(Executions.getCurrent().getDesktop().getFirstPage().getFirstRoot());
            }
            w.doModal();
        } catch (Exception e) {
            LOGGER.error("Error showing intervals dialog", e);
        }
    }

    private List<String> computeIntervalsForType(String type) {
        List<String> out = new ArrayList<>();
        if (apmLog == null) return out;
        long start = apmLog.getStartTime();
        long end = apmLog.getEndTime();
        java.util.Calendar cal = java.util.Calendar.getInstance();
        cal.setTimeInMillis(start);
        switch (type) {
            case "Year":
                while (cal.getTimeInMillis() <= end) {
                    out.add(String.valueOf(cal.get(java.util.Calendar.YEAR)));
                    cal.add(java.util.Calendar.YEAR, 1);
                }
                break;
            case "Month":
                while (cal.getTimeInMillis() <= end) {
                    int y = cal.get(java.util.Calendar.YEAR);
                    int m = cal.get(java.util.Calendar.MONTH) + 1;
                    out.add(String.format("%04d-%02d", y, m));
                    cal.add(java.util.Calendar.MONTH, 1);
                }
                break;
            case "Week":
                while (cal.getTimeInMillis() <= end) {
                    int y = cal.get(java.util.Calendar.YEAR);
                    int w = cal.get(java.util.Calendar.WEEK_OF_YEAR);
                    out.add(String.format("%04d-W%02d", y, w));
                    cal.add(java.util.Calendar.WEEK_OF_YEAR, 1);
                }
                break;
            case "Quarter":
                while (cal.getTimeInMillis() <= end) {
                    int y = cal.get(java.util.Calendar.YEAR);
                    int q = (cal.get(java.util.Calendar.MONTH) / 3) + 1;
                    out.add(String.format("%04d-Q%d", y, q));
                    cal.add(java.util.Calendar.MONTH, 3);
                }
                break;
            case "Semester":
                while (cal.getTimeInMillis() <= end) {
                    int y = cal.get(java.util.Calendar.YEAR);
                    int s = (cal.get(java.util.Calendar.MONTH) / 6) + 1;
                    out.add(String.format("%04d-S%d", y, s));
                    cal.add(java.util.Calendar.MONTH, 6);
                }
                break;
            default:
                break;
        }
        return out;
    }

    private boolean isPredefinedMode() {
        return usePredefinedTimeframes != null && usePredefinedTimeframes.isChecked();
    }

    private void disableManualDates(boolean disabled) {
        if (fromDate != null) fromDate.setDisabled(disabled);
        if (toDate != null) toDate.setDisabled(disabled);
    }

    private boolean containmentLocked = false;
    private void setContainmentLocked(boolean locked) {
        this.containmentLocked = locked;
        if (locked) {
            if (startInIcon != null) startInIcon.setSclass("containment-icon inactive");
            if (endInIcon != null) endInIcon.setSclass("containment-icon inactive");
            if (containedInIcon != null) containedInIcon.setSclass("containment-icon inactive");
            if (activeInIcon != null) activeInIcon.setSclass("containment-icon inactive");
        } else {
            refreshContainmentIconStyles();
        }
    }

    private long[] computePredefinedRange() {
        long min = Long.MAX_VALUE;
        long max = Long.MIN_VALUE;
        if (apmLog == null) return new long[] {System.currentTimeMillis(), System.currentTimeMillis()};
        if (selectedPredefinedIntervals == null || selectedPredefinedIntervals.isEmpty()) {
            // If nothing selected, default to whole log
            return new long[] {apmLog.getStartTime(), apmLog.getEndTime()};
        }
        for (String token : selectedPredefinedIntervals) {
            long[] b = boundsForToken(selectedPredefinedType, token, apmLog.getStartTime(), apmLog.getEndTime());
            if (b[0] < min) min = b[0];
            if (b[1] > max) max = b[1];
        }
        if (min == Long.MAX_VALUE || max == Long.MIN_VALUE) {
            return new long[] {apmLog.getStartTime(), apmLog.getEndTime()};
        }
        return new long[] {min, max};
    }

    private long[] boundsForToken(String type, String token, long logStart, long logEnd) {
        java.util.Calendar cal = java.util.Calendar.getInstance();
        try {
            if ("Year".equals(type)) {
                int y = Integer.parseInt(token);
                cal.clear();
                cal.set(java.util.Calendar.YEAR, y);
                long start = startOfYear(cal);
                long end = endOfYear(cal);
                return clampToLog(start, end, logStart, logEnd);
            } else if ("Month".equals(type)) {
                String[] parts = token.split("-");
                int y = Integer.parseInt(parts[0]);
                int m = Integer.parseInt(parts[1]);
                cal.clear();
                cal.set(java.util.Calendar.YEAR, y);
                cal.set(java.util.Calendar.MONTH, m - 1);
                long start = startOfMonth(cal);
                long end = endOfMonth(cal);
                return clampToLog(start, end, logStart, logEnd);
            } else if ("Week".equals(type)) {
                String[] parts = token.split("-W");
                int y = Integer.parseInt(parts[0]);
                int w = Integer.parseInt(parts[1]);
                cal.clear();
                cal.setFirstDayOfWeek(java.util.Calendar.MONDAY);
                cal.set(java.util.Calendar.YEAR, y);
                cal.set(java.util.Calendar.WEEK_OF_YEAR, w);
                long start = startOfWeek(cal);
                long end = endOfWeek(cal);
                return clampToLog(start, end, logStart, logEnd);
            } else if ("Quarter".equals(type)) {
                String[] parts = token.split("-Q");
                int y = Integer.parseInt(parts[0]);
                int q = Integer.parseInt(parts[1]);
                cal.clear();
                cal.set(java.util.Calendar.YEAR, y);
                cal.set(java.util.Calendar.MONTH, (q - 1) * 3);
                long start = startOfMonth(cal);
                cal.add(java.util.Calendar.MONTH, 3);
                cal.add(java.util.Calendar.MILLISECOND, -1);
                long end = cal.getTimeInMillis();
                return clampToLog(start, end, logStart, logEnd);
            } else if ("Semester".equals(type)) {
                String[] parts = token.split("-S");
                int y = Integer.parseInt(parts[0]);
                int s = Integer.parseInt(parts[1]);
                cal.clear();
                cal.set(java.util.Calendar.YEAR, y);
                cal.set(java.util.Calendar.MONTH, (s - 1) * 6);
                long start = startOfMonth(cal);
                cal.add(java.util.Calendar.MONTH, 6);
                cal.add(java.util.Calendar.MILLISECOND, -1);
                long end = cal.getTimeInMillis();
                return clampToLog(start, end, logStart, logEnd);
            }
        } catch (Exception e) {
            LOGGER.warn("Failed to parse predefined token: type={}, token={}", type, token, e);
        }
        return new long[] {logStart, logEnd};
    }

    private long[] clampToLog(long start, long end, long logStart, long logEnd) {
        if (start < logStart) start = logStart;
        if (end > logEnd) end = logEnd;
        return new long[] {start, end};
    }

    private long startOfYear(java.util.Calendar cal) {
        cal.set(java.util.Calendar.DAY_OF_YEAR, 1);
        cal.set(java.util.Calendar.HOUR_OF_DAY, 0);
        cal.set(java.util.Calendar.MINUTE, 0);
        cal.set(java.util.Calendar.SECOND, 0);
        cal.set(java.util.Calendar.MILLISECOND, 0);
        return cal.getTimeInMillis();
    }

    private long endOfYear(java.util.Calendar cal) {
        cal.set(java.util.Calendar.DAY_OF_YEAR, 1);
        cal.add(java.util.Calendar.YEAR, 1);
        cal.add(java.util.Calendar.MILLISECOND, -1);
        return cal.getTimeInMillis();
    }

    private long startOfMonth(java.util.Calendar cal) {
        cal.set(java.util.Calendar.DAY_OF_MONTH, 1);
        cal.set(java.util.Calendar.HOUR_OF_DAY, 0);
        cal.set(java.util.Calendar.MINUTE, 0);
        cal.set(java.util.Calendar.SECOND, 0);
        cal.set(java.util.Calendar.MILLISECOND, 0);
        return cal.getTimeInMillis();
    }

    private long endOfMonth(java.util.Calendar cal) {
        cal.set(java.util.Calendar.DAY_OF_MONTH, 1);
        cal.add(java.util.Calendar.MONTH, 1);
        cal.add(java.util.Calendar.MILLISECOND, -1);
        return cal.getTimeInMillis();
    }

    private long startOfWeek(java.util.Calendar cal) {
        cal.set(java.util.Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek());
        cal.set(java.util.Calendar.HOUR_OF_DAY, 0);
        cal.set(java.util.Calendar.MINUTE, 0);
        cal.set(java.util.Calendar.SECOND, 0);
        cal.set(java.util.Calendar.MILLISECOND, 0);
        return cal.getTimeInMillis();
    }

    private long endOfWeek(java.util.Calendar cal) {
        cal.set(java.util.Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek());
        cal.add(java.util.Calendar.DAY_OF_YEAR, 7);
        cal.add(java.util.Calendar.MILLISECOND, -1);
        return cal.getTimeInMillis();
    }

    /**
     * Update statistics labels safely
     */
    private void updateStatistics() {
        try {
            if (apmLog != null) {
                loadRealLogStatistics();
            }
        } catch (Exception e) {
            LOGGER.error("Error updating statistics", e);
        }
    }

    /**
     * Applying filters button in performance panel
     */
    @Listen("onClick = #applyFiltersBtnPerformance")
    public void onApplyPerformanceFiltersClick() {
        try {
            LOGGER.info("Applying performance filters...");
            currentFilter = "performance";
            applyFiltersAndRedirect();
        } catch (Exception e) {
            LOGGER.error("Error applying performance filters", e);
        }
    }

    private List<LogFilterRule> createPerformanceFilterRules() {
        List<LogFilterRule> rules = new ArrayList<>();
        try {
            String condition = performanceCondition != null && performanceCondition.getSelectedItem() != null ? performanceCondition.getSelectedItem().getValue() : "retain";
            Choice choice = "retain".equals(condition) ? Choice.RETAIN : Choice.REMOVE;
            String measure = performanceMeasure != null && performanceMeasure.getSelectedItem() != null ? performanceMeasure.getSelectedItem().getLabel() : "Case duration";

            if ("Case length".equals(measure)) {
                int from = perfLenFrom != null && perfLenFrom.getValue() != null ? perfLenFrom.getValue() : Integer.MIN_VALUE;
                int to = perfLenTo != null && perfLenTo.getValue() != null ? perfLenTo.getValue() : Integer.MAX_VALUE;
                if (from > to) { int t = from; from = to; to = t; }
                Set<RuleValue> rvs = new HashSet<>();
                if (from != Integer.MIN_VALUE) {
                    rvs.add(new RuleValue(FilterType.CASE_LENGTH, OperationType.GREATER_EQUAL, "case:length", (long) from));
                }
                if (to != Integer.MAX_VALUE) {
                    rvs.add(new RuleValue(FilterType.CASE_LENGTH, OperationType.LESS_EQUAL, "case:length", (long) to));
                }
                if (!rvs.isEmpty()) {
                    LogFilterRule rule = LogFilterRuleImpl.init(FilterType.CASE_LENGTH, choice == Choice.RETAIN, rvs);
                    rules.add(rule);
                    LOGGER.info("Created performance rule (Case length): from={}, to={}, retain={}", from, to, choice == Choice.RETAIN);
                }
                return rules;
            }

            // Processing time family (average, maximum, total) and default case duration
            long gteMs = toMillis(perfGteValue, perfGteUnit);
            long lteMs = toMillis(perfLteValue, perfLteUnit);
            if (gteMs > 0 && lteMs > 0 && lteMs < gteMs) {
                long t = gteMs; gteMs = lteMs; lteMs = t;
            }
            Set<RuleValue> ruleValues = new HashSet<>();
            if (gteMs > 0) {
                ruleValues.add(new RuleValue(resolveDurationFilterType(measure), OperationType.GREATER_EQUAL, durationKeyForMeasure(measure), gteMs));
            }
            if (lteMs > 0) {
                ruleValues.add(new RuleValue(resolveDurationFilterType(measure), OperationType.LESS_EQUAL, durationKeyForMeasure(measure), lteMs));
            }
            if (!ruleValues.isEmpty()) {
                LogFilterRule rule = LogFilterRuleImpl.init(resolveDurationFilterType(measure), choice == Choice.RETAIN, ruleValues);
                rules.add(rule);
                LOGGER.info("Created performance rule ({}): gteMs={}, lteMs={}, retain={}", measure, gteMs, lteMs, choice == Choice.RETAIN);
            }

        } catch (Exception e) {
            LOGGER.error("Error creating performance filter rules", e);
        }
        return rules;
    }

    private long toMillis(Intbox valBox, Combobox unitBox) {
        try {
            int value = (valBox != null && valBox.getValue() != null) ? valBox.getValue() : 0;
            if (value <= 0) return 0L;
            String unit = unitBox != null && unitBox.getSelectedItem() != null ? unitBox.getSelectedItem().getLabel() : "Seconds";
            long base = 1000L;
            switch (unit) {
                case "Years": return value * 365L * 24 * 60 * 60 * 1000;
                case "Months": return value * 30L * 24 * 60 * 60 * 1000;
                case "Weeks": return value * 7L * 24 * 60 * 60 * 1000;
                case "Days": return value * 24L * 60 * 60 * 1000;
                case "Hours": return value * 60L * 60 * 1000;
                case "Minutes": return value * 60L * 1000;
                case "Seconds": default: return value * base;
            }
        } catch (Exception e) {
            return 0L;
        }
    }

    @Listen("onSelect = #performanceMeasure")
    public void onPerformanceMeasureChange() {
        try {
            String measure = performanceMeasure != null && performanceMeasure.getSelectedItem() != null ? performanceMeasure.getSelectedItem().getLabel() : "";
            boolean isCaseLength = "Case length".equals(measure);
            boolean needsDurationBounds = "Case duration".equals(measure)
                || "Processing time (average)".equals(measure)
                || "Processing time (maximum)".equals(measure)
                || "Processing time (total)".equals(measure)
                || "Waiting time (average)".equals(measure)
                || "Waiting time (maximum)".equals(measure)
                || "Waiting time (total)".equals(measure)
                || "Case utilization".equals(measure)
                || "Node duration".equals(measure)
                || "Arc duration".equals(measure);
            if (perfGteRow != null) perfGteRow.setVisible(needsDurationBounds && !isCaseLength);
            if (perfLteRow != null) perfLteRow.setVisible(needsDurationBounds && !isCaseLength);
            if (perfLenRow != null) perfLenRow.setVisible(isCaseLength);

            // Defaults for Case duration: GTE=0 Years, LTE=max duration in Years
            if ("Case duration".equals(measure)) {
                if (perfGteValue != null) perfGteValue.setValue(0);
                if (perfLteValue != null) {
                    long maxMs = computeMaxCaseDurationMs();
                    long yearMs = 365L * 24 * 60 * 60 * 1000;
                    int years = (int) Math.ceil((double) Math.max(maxMs, 0L) / (double) yearMs);
                    if (years < 1) years = 1; // ensure at least 1 when there is any duration
                    perfLteValue.setValue(years);
                }
                selectComboByLabel(perfGteUnit, "Years");
                selectComboByLabel(perfLteUnit, "Years");
            }

            // Defaults for Case length: From=min, To=max
            if ("Case length".equals(measure)) {
                int[] minMax = computeMinMaxCaseLength();
                if (perfLenFrom != null) perfLenFrom.setValue(minMax[0]);
                if (perfLenTo != null) perfLenTo.setValue(minMax[1]);
            }

            // Defaults for Processing time (average): GTE=0 Days, LTE=max avg processing time in Days
            if ("Processing time (average)".equals(measure)) {
                if (perfGteValue != null) perfGteValue.setValue(0);
                if (perfLteValue != null) {
                    long maxAvgMs = computeMaxAverageProcessingTimeMs();
                    long dayMs = 24L * 60 * 60 * 1000;
                    int days = (int) Math.ceil((double) Math.max(maxAvgMs, 0L) / (double) dayMs);
                    if (days < 1 && maxAvgMs > 0L) days = 1;
                    perfLteValue.setValue(days);
                }
                selectComboByLabel(perfGteUnit, "Days");
                selectComboByLabel(perfLteUnit, "Days");
            }
        } catch (Exception e) {
            LOGGER.error("Error handling performance measure change", e);
        }
    }

    private void selectComboByLabel(Combobox combo, String label) {
        if (combo == null || label == null) return;
        try {
            for (Comboitem item : combo.getItems()) {
                if (label.equals(item.getLabel())) {
                    combo.setSelectedItem(item);
                    return;
                }
            }
        } catch (Exception ignored) {}
    }

    private long computeMaxCaseDurationMs() {
        try {
            if (apmLog == null || apmLog.getTraces() == null) return 0L;
            long max = 0L;
            for (ATrace trace : apmLog.getTraces()) {
                try {
                    long start = trace.getStartTime();
                    long end = trace.getEndTime();
                    if (end >= start) {
                        long d = end - start;
                        if (d > max) max = d;
                    }
                } catch (Exception ignored) {}
            }
            if (max <= 0L) {
                // fallback to whole log duration
                try {
                    long d = apmLog.getEndTime() - apmLog.getStartTime();
                    if (d > max) max = d;
                } catch (Exception ignored) {}
            }
            return Math.max(0L, max);
        } catch (Exception e) {
            return 0L;
        }
    }

    private int[] computeMinMaxCaseLength() {
        int min = Integer.MAX_VALUE;
        int max = 0;
        try {
            if (apmLog == null || apmLog.getTraces() == null || apmLog.getTraces().isEmpty()) {
                return new int[] {0, 0};
            }
            for (ATrace trace : apmLog.getTraces()) {
                try {
                    int len = trace.getActivityInstances() != null ? trace.getActivityInstances().size() : 0;
                    if (len < min) min = len;
                    if (len > max) max = len;
                } catch (Exception ignored) {}
            }
            if (min == Integer.MAX_VALUE) min = 0;
            return new int[] {min, max};
        } catch (Exception e) {
            return new int[] {0, 0};
        }
    }

    private long computeMaxAverageProcessingTimeMs() {
        try {
            if (apmLog == null || apmLog.getTraces() == null || apmLog.getTraces().isEmpty()) return 0L;
            double maxAvg = 0.0;
            for (ATrace trace : apmLog.getTraces()) {
                try {
                    if (trace == null || trace.getActivityInstances() == null || trace.getActivityInstances().isEmpty()) continue;
                    double sum = 0.0;
                    int count = 0;
                    for (ActivityInstance ai : trace.getActivityInstances()) {
                        double d = ai != null ? ai.getDuration() : 0.0;
                        if (d > 0.0) {
                            sum += d;
                            count++;
                        }
                    }
                    if (count > 0) {
                        double avg = sum / (double) count;
                        if (avg > maxAvg) maxAvg = avg;
                    }
                } catch (Exception ignored) {}
            }
            if (maxAvg <= 0.0) return 0L;
            return (long) Math.ceil(maxAvg);
        } catch (Exception e) {
            return 0L;
        }
    }

    /**
     * Initialize performance filter components
     */
    private void initializePerformanceFilter() {
        try {
            // Default measure: Case duration
            if (performanceMeasure != null && performanceMeasure.getItemCount() > 0) {
                performanceMeasure.setSelectedIndex(0);
            }
            // Ensure proper rows visibility
            onPerformanceMeasureChange();
        } catch (Exception e) {
            LOGGER.error("Error initializing performance filter", e);
        }
    }

    private FilterType resolveDurationFilterType(String measure) {
        if ("Processing time (average)".equals(measure)) return FilterType.AVERAGE_PROCESSING_TIME;
        if ("Processing time (maximum)".equals(measure)) return FilterType.MAX_PROCESSING_TIME;
        if ("Processing time (total)".equals(measure)) return FilterType.TOTAL_PROCESSING_TIME;
        return FilterType.DURATION; // Case duration default
    }

    private String durationKeyForMeasure(String measure) {
        if ("Processing time (average)".equals(measure)) return "duration:average_processing";
        if ("Processing time (maximum)".equals(measure)) return "duration:max_processing";
        if ("Processing time (total)".equals(measure)) return "duration:total_processing";
        return "duration:range"; // Case duration default
    }
}